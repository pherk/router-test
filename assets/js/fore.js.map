{"version":3,"file":"fore.js","sources":["../src/DependencyNotifyingDomFacade.js","../src/xpath-util.js","../src/dep_graph.js","../src/fore.js","../src/xpath-evaluation.js","../src/fx-instance.js","../src/modelitem.js","../src/fx-model.js","../src/getInScopeContext.js","../src/ForeElementMixin.js","../src/fx-bind.js","../src/fx-fore.js","../src/fx-submission.js","../src/fx-header.js","../src/ui/abstract-control.js","../src/ui/fx-alert.js","../src/ui/fx-control.js","../src/ui/fx-container.js","../src/ui/fx-group.js","../src/ui/fx-hint.js","../src/ui/fx-output.js","../src/ui/fx-repeatitem.js","../src/ui/fx-repeat.js","../src/ui/fx-switch.js","../src/ui/fx-trigger.js","../src/ui/fx-case.js","../src/actions/abstract-action.js","../src/actions/fx-append.js","../src/actions/fx-delete.js","../src/actions/fx-insert.js","../src/actions/fx-message.js","../src/actions/fx-setvalue.js","../src/actions/fx-send.js","../src/actions/fx-action.js","../src/actions/fx-toggle.js","../src/actions/fx-dispatch.js","../src/actions/fx-update.js","../src/actions/fx-refresh.js","../src/actions/fx-confirm.js","../src/functions/fx-function.js"],"sourcesContent":["import { getBucketsForNode } from 'fontoxpath';\n\n/**\n * A DomFacade that will intercept any and all accesses to _nodes_ from an XPath. Basically the same\n * as the `depends` function, but less explicit and will automatically be called for any node that\n * will be touched in the XPath.\n *\n * Maybe some more granularity is better. Maybe only notify a node's attributes are touched?\n */\nexport class DependencyNotifyingDomFacade {\n  /**\n   * @param  {function(touchedNode: Node): void)} onNodeTouched A function what will be executed whenever a node is 'touched' by the XPath\n   */\n  constructor(onNodeTouched) {\n    this._onNodeTouched = onNodeTouched;\n  }\n\n  /**\n   * Get all attributes of this element.\n   * The bucket can be used to narrow down which attributes should be retrieved.\n   *\n   * @param  node -\n   */\n  // eslint-disable-next-line class-methods-use-this\n  getAllAttributes(node) {\n    return Array.from(node.attributes);\n  }\n\n  /**\n   * Get the value of specified attribute of this element.\n   *\n   * @param  node -\n   * @param  attributeName -\n   */\n  // eslint-disable-next-line class-methods-use-this\n  getAttribute(node, attributeName) {\n    return node.getAttribute(attributeName);\n  }\n\n  /**\n   * Get all child nodes of this element.\n   * The bucket can be used to narrow down which child nodes should be retrieved.\n   *\n   * @param  node -\n   * @param  bucket - The bucket that matches the attribute that will be used.\n   */\n  // eslint-disable-next-line class-methods-use-this\n  getChildNodes(node, bucket) {\n    const matchingNodes = Array.from(node.childNodes).filter(\n      childNode => !bucket || getBucketsForNode(childNode).includes(bucket),\n    );\n    return matchingNodes;\n  }\n\n  /**\n   * Get the data of this node.\n   *\n   * @param  node -\n   */\n  getData(node) {\n    if (node.nodeType === Node.ATTRIBUTE_NODE) {\n      this._onNodeTouched(node);\n      return node.value;\n    }\n    // Text node\n    this._onNodeTouched(node.parentNode);\n    return node.data;\n  }\n\n  /**\n   * Get the first child of this element.\n   * An implementation of IDomFacade is free to interpret the bucket to skip returning nodes that do not match the bucket, or use this information to its advantage.\n   *\n   * @param  node -\n   * @param  bucket - The bucket that matches the attribute that will be used.\n   */\n  getFirstChild(node, bucket) {\n    const matchingNode = Array.from(this.getChildNodes()).filter(\n      childNode => !bucket || getBucketsForNode(childNode).includes(bucket),\n    )[0];\n    if (matchingNode) {\n      return matchingNode;\n    }\n    return null;\n  }\n\n  /**\n   * Get the last child of this element.\n   * An implementation of IDomFacade is free to interpret the bucket to skip returning nodes that do not match the bucket, or use this information to its advantage.\n   *\n   * @param  node -\n   * @param  bucket - The bucket that matches the attribute that will be used.\n   */\n  // eslint-disable-next-line class-methods-use-this\n  getLastChild(node, bucket) {\n    const matchingNodes = node\n      .getChildNodes()\n      .filter(childNode => !bucket || getBucketsForNode(childNode).includes(bucket));\n    const matchNode = matchingNodes[matchingNodes.length - 1];\n    if (matchNode) {\n      return matchNode;\n    }\n    return null;\n  }\n\n  /**\n   * Get the next sibling of this node\n   * An implementation of IDomFacade is free to interpret the bucket to skip returning nodes that do not match the bucket, or use this information to its advantage.\n   *\n   * @param  node -\n   * @param  bucket - The bucket that matches the nextSibling that is requested.\n   */\n  // eslint-disable-next-line class-methods-use-this\n  getNextSibling(node, bucket) {\n    for (let { nextSibling } = node; nextSibling; nextSibling = nextSibling.nextSibling) {\n      if (!getBucketsForNode(nextSibling).includes(bucket)) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      return nextSibling;\n    }\n    return null;\n  }\n\n  /**\n   * Get the parent of this element.\n   * An implementation of IDomFacade is free to interpret the bucket to skip returning nodes that do not match the bucket, or use this information to its advantage.\n   *\n   * @param  node -\n   * @param  bucket - The bucket that matches the attribute that will be used.\n   */\n  // eslint-disable-next-line class-methods-use-this\n  getParentNode(node) {\n    return node.parentNode;\n  }\n\n  /**\n   * Get the previous sibling of this element.\n   * An implementation of IDomFacade is free to interpret the bucket to skip returning nodes that do not match the bucket, or use this information to its advantage.\n   *\n   * @param  node -\n   * @param  bucket - The bucket that matches the attribute that will be used.\n   */\n  // eslint-disable-next-line class-methods-use-this\n  getPreviousSibling(node, bucket) {\n    for (\n      let { previousSibling } = node;\n      previousSibling;\n      previousSibling = previousSibling.previousSibling\n    ) {\n      if (!getBucketsForNode(previousSibling).includes(bucket)) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      return previousSibling;\n    }\n    return null;\n  }\n}\n","import * as fx from 'fontoxpath';\n\n/**\n * Checks wether the specified path expression is an absolute path.\n *\n * @param path the path expression.\n * @return <code>true</code> if specified path expression is an absolute\n * path, otherwise <code>false</code>.\n */\n\nexport class XPathUtil {\n  static isAbsolutePath(path) {\n    return path != null && (path.startsWith('/') || path.startsWith('instance('));\n  }\n\n  static isSelfReference(ref) {\n    return ref === '.' || ref === './text()' || ref === 'text()' || ref === '' || ref === null;\n  }\n\n  // todo: this will need more work to look upward for instance() expr.\n  static getInstanceId(ref) {\n    if (!ref) {\n      return 'default';\n    }\n    if (ref.startsWith('instance(')) {\n      const result = ref.substring(ref.indexOf('(') + 1);\n      return result.substring(1, result.indexOf(')') - 1);\n    }\n    return 'default';\n  }\n\n  // todo: certainly not ideal to rely on duplicating instance id on instance document - better way later ;)\n  static getPath(node) {\n    const path = fx.evaluateXPath('path()', node);\n    const instanceId = node.ownerDocument.firstElementChild.getAttribute('id');\n    if (instanceId !== null && instanceId !== 'default') {\n      return `#${instanceId}${XPathUtil.shortenPath(path)}`;\n    }\n    return XPathUtil.shortenPath(path);\n  }\n\n  static shortenPath(path) {\n    const steps = path.split('/');\n    let result = '';\n    for (let i = 2; i < steps.length; i += 1) {\n      const step = steps[i];\n      if (step.indexOf('{}') !== -1) {\n        const q = step.split('{}');\n        result += `/${q[1]}`;\n      } else {\n        result += `/${step}`;\n      }\n    }\n    return result;\n  }\n}\n","/**\n * A simple dependency graph\n *\n * based on the work of https://github.com/jriecken/dependency-graph but working on ES6.\n *\n * Furthermore instead of the DepGraphCycleError a compute-exception event is dispatched.\n *\n *\n */\n\n/**\n * Cycle error, including the path of the cycle.\n */\n// const DepGraphCycleError = (exports.DepGraphCycleError = function (cyclePath) {\n\n/*\nexport function DepGraphCycleError(cyclePath) {\n  const message = \"Dependency Cycle Found: \" + cyclePath.join(\" -> \");\n  const instance = new Error(message);\n  instance.cyclePath = cyclePath;\n  Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(instance, DepGraphCycleError);\n  }\n  return instance;\n};\n\nDepGraphCycleError.prototype = Object.create(Error.prototype, {\n  constructor: {\n    value: Error,\n    enumerable: false,\n    writable: true,\n    configurable: true\n  }\n});\nObject.setPrototypeOf(DepGraphCycleError, Error);\n*/\n\n/**\n * Helper for creating a Topological Sort using Depth-First-Search on a set of edges.\n *\n * Detects cycles and throws an Error if one is detected (unless the \"circular\"\n * parameter is \"true\" in which case it ignores them).\n *\n * @param edges The set of edges to DFS through\n * @param leavesOnly Whether to only return \"leaf\" nodes (ones who have no edges)\n * @param result An array in which the results will be populated\n * @param circular A boolean to allow circular dependencies\n */\nfunction createDFS(edges, leavesOnly, result, circular) {\n  const visited = {};\n  // eslint-disable-next-line func-names\n  return function(start) {\n    // console.log('start ', start);\n    if (visited[start]) {\n      return;\n    }\n    const inCurrentPath = {};\n    const currentPath = [];\n    const todo = []; // used as a stack\n    todo.push({ node: start, processed: false });\n    while (todo.length > 0) {\n      const current = todo[todo.length - 1]; // peek at the todo stack\n      const { processed } = current;\n      const { node } = current;\n      if (!processed) {\n        // Haven't visited edges yet (visiting phase)\n        if (visited[node]) {\n          todo.pop();\n          // eslint-disable-next-line no-continue\n          continue;\n        } else if (inCurrentPath[node]) {\n          // It's not a DAG\n          if (circular) {\n            todo.pop();\n            // If we're tolerating cycles, don't revisit the node\n            // eslint-disable-next-line no-continue\n            continue;\n          }\n          currentPath.push(node);\n          window.dispatchEvent(\n            new CustomEvent('compute-exception', {\n              composed: true,\n              bubbles: true,\n              detail: {\n                path: currentPath,\n                message: 'cyclic graph',\n              },\n            }),\n          );\n          // return;\n          // console.log('â€˜circular path: ' + currentPath);\n          // throw new DepGraphCycleError(currentPath);\n          // throw new Error(currentPath);\n        }\n\n        inCurrentPath[node] = true;\n        currentPath.push(node);\n        const nodeEdges = edges[node];\n        // (push edges onto the todo stack in reverse order to be order-compatible with the old DFS implementation)\n        for (let i = nodeEdges.length - 1; i >= 0; i -= 1) {\n          todo.push({ node: nodeEdges[i], processed: false });\n        }\n        current.processed = true;\n      } else {\n        // Have visited edges (stack unrolling phase)\n        todo.pop();\n        currentPath.pop();\n        inCurrentPath[node] = false;\n        visited[node] = true;\n        if (!leavesOnly || edges[node].length === 0) {\n          result.push(node);\n        }\n      }\n    }\n  };\n}\n\n/**\n * Simple Dependency Graph\n */\n\n/*\nvar DepGraph = (exports.DepGraph = function DepGraph(opts) {\n  this.nodes = {}; // Node -> Node/Data (treated like a Set)\n  this.outgoingEdges = {}; // Node -> [Dependency Node]\n  this.incomingEdges = {}; // Node -> [Dependant Node]\n  this.circular = opts && !!opts.circular; // Allows circular deps\n});\n*/\n\nexport function DepGraph(opts) {\n  this.nodes = {}; // Node -> Node/Data (treated like a Set)\n  this.outgoingEdges = {}; // Node -> [Dependency Node]\n  this.incomingEdges = {}; // Node -> [Dependant Node]\n  this.circular = opts && !!opts.circular; // Allows circular deps\n}\n\nDepGraph.prototype = {\n  /**\n   * The number of nodes in the graph.\n   */\n  size() {\n    return Object.keys(this.nodes).length;\n  },\n  /**\n   * Add a node to the dependency graph. If a node already exists, this method will do nothing.\n   */\n  addNode(node, data) {\n    if (!this.hasNode(node)) {\n      // Checking the arguments length allows the user to add a node with undefined data\n      if (arguments.length === 2) {\n        this.nodes[node] = data;\n      } else {\n        this.nodes[node] = node;\n      }\n      this.outgoingEdges[node] = [];\n      this.incomingEdges[node] = [];\n    }\n  },\n  /**\n   * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.\n   */\n  removeNode(node) {\n    if (this.hasNode(node)) {\n      delete this.nodes[node];\n      delete this.outgoingEdges[node];\n      delete this.incomingEdges[node];\n      // [this.incomingEdges, this.outgoingEdges].forEach(function (edgeList) {\n      [this.incomingEdges, this.outgoingEdges].forEach(edgeList => {\n        Object.keys(edgeList).forEach(key => {\n          const idx = edgeList[key].indexOf(node);\n          if (idx >= 0) {\n            edgeList[key].splice(idx, 1);\n          }\n        }, this);\n      });\n    }\n  },\n  /**\n   * Check if a node exists in the graph\n   */\n  hasNode(node) {\n    // return this.nodes.hasOwnProperty(node);\n\n    return Object.prototype.hasOwnProperty.call(this.nodes, node);\n  },\n  /**\n   * Get the data associated with a node name\n   */\n  getNodeData(node) {\n    if (this.hasNode(node)) {\n      return this.nodes[node];\n    }\n    throw new Error(`Node does not exist: ${node}`);\n  },\n  /**\n   * Set the associated data for a given node name. If the node does not exist, this method will throw an error\n   */\n  setNodeData(node, data) {\n    if (this.hasNode(node)) {\n      this.nodes[node] = data;\n    } else {\n      throw new Error(`Node does not exist: ${node}`);\n    }\n  },\n  /**\n   * Add a dependency between two nodes. If either of the nodes does not exist,\n   * an Error will be thrown.\n   */\n  addDependency(from, to) {\n    if (!this.hasNode(from)) {\n      throw new Error(`Node does not exist: ${from}`);\n    }\n    if (!this.hasNode(to)) {\n      throw new Error(`Node does not exist: ${to}`);\n    }\n    if (this.outgoingEdges[from].indexOf(to) === -1) {\n      this.outgoingEdges[from].push(to);\n    }\n    if (this.incomingEdges[to].indexOf(from) === -1) {\n      this.incomingEdges[to].push(from);\n    }\n    return true;\n  },\n  /**\n   * Remove a dependency between two nodes.\n   */\n  removeDependency(from, to) {\n    let idx;\n    if (this.hasNode(from)) {\n      idx = this.outgoingEdges[from].indexOf(to);\n      if (idx >= 0) {\n        this.outgoingEdges[from].splice(idx, 1);\n      }\n    }\n\n    if (this.hasNode(to)) {\n      idx = this.incomingEdges[to].indexOf(from);\n      if (idx >= 0) {\n        this.incomingEdges[to].splice(idx, 1);\n      }\n    }\n  },\n  /**\n   * Return a clone of the dependency graph. If any custom data is attached\n   * to the nodes, it will only be shallow copied.\n   */\n  clone() {\n    const source = this;\n    const result = new DepGraph();\n    const keys = Object.keys(source.nodes);\n    keys.forEach(n => {\n      result.nodes[n] = source.nodes[n];\n      result.outgoingEdges[n] = source.outgoingEdges[n].slice(0);\n      result.incomingEdges[n] = source.incomingEdges[n].slice(0);\n    });\n    return result;\n  },\n  /**\n   * Get an array containing the direct dependencies of the specified node.\n   *\n   * Throws an Error if the specified node does not exist.\n   */\n  directDependenciesOf(node) {\n    if (this.hasNode(node)) {\n      return this.outgoingEdges[node].slice(0);\n    }\n    throw new Error(`Node does not exist: ${node}`);\n  },\n  /**\n   * Get an array containing the nodes that directly depend on the specified node.\n   *\n   * Throws an Error if the specified node does not exist.\n   */\n  directDependantsOf(node) {\n    if (this.hasNode(node)) {\n      return this.incomingEdges[node].slice(0);\n    }\n    throw new Error(`Node does not exist: ${node}`);\n  },\n  /**\n   * Get an array containing the nodes that the specified node depends on (transitively).\n   *\n   * Throws an Error if the graph has a cycle, or the specified node does not exist.\n   *\n   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned\n   * in the array.\n   */\n  dependenciesOf(node, leavesOnly) {\n    if (this.hasNode(node)) {\n      const result = [];\n      const DFS = createDFS(this.outgoingEdges, leavesOnly, result, this.circular);\n      DFS(node);\n      const idx = result.indexOf(node);\n      if (idx >= 0) {\n        result.splice(idx, 1);\n      }\n      return result;\n    }\n    throw new Error(`Node does not exist: ${node}`);\n  },\n  /**\n   * get an array containing the nodes that depend on the specified node (transitively).\n   *\n   * Throws an Error if the graph has a cycle, or the specified node does not exist.\n   *\n   * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.\n   */\n  dependantsOf(node, leavesOnly) {\n    if (this.hasNode(node)) {\n      const result = [];\n      const DFS = createDFS(this.incomingEdges, leavesOnly, result, this.circular);\n      DFS(node);\n      const idx = result.indexOf(node);\n      if (idx >= 0) {\n        result.splice(idx, 1);\n      }\n      return result;\n    }\n    throw new Error(`Node does not exist: ${node}`);\n  },\n  /**\n   * Construct the overall processing order for the dependency graph.\n   *\n   * Throws an Error if the graph has a cycle.\n   *\n   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.\n   */\n  overallOrder(leavesOnly) {\n    const self = this;\n    const result = [];\n    const keys = Object.keys(this.nodes);\n    if (keys.length === 0) {\n      return result; // Empty graph\n    }\n    if (!this.circular) {\n      // Look for cycles - we run the DFS starting at all the nodes in case there\n      // are several disconnected subgraphs inside this dependency graph.\n      const CycleDFS = createDFS(this.outgoingEdges, false, [], this.circular);\n      keys.forEach(n => {\n        CycleDFS(n);\n      });\n    }\n\n    const DFS = createDFS(this.outgoingEdges, leavesOnly, result, this.circular);\n    // Find all potential starting points (nodes with nothing depending on them) an\n    // run a DFS starting at these points to get the order\n    keys\n      .filter(node => self.incomingEdges[node].length === 0)\n      .forEach(n => {\n        DFS(n);\n      });\n\n    // If we're allowing cycles - we need to run the DFS against any remaining\n    // nodes that did not end up in the initial result (as they are part of a\n    // subgraph that does not have a clear starting point)\n    if (this.circular) {\n      keys.filter(node => result.indexOf(node) === -1).forEach(n => DFS(n));\n    }\n\n    return result;\n  },\n};\n\n// Create some aliases\nDepGraph.prototype.directDependentsOf = DepGraph.prototype.directDependantsOf;\nDepGraph.prototype.dependentsOf = DepGraph.prototype.dependantsOf;\n","export class Fore {\n  static READONLY_DEFAULT = false;\n\n  static REQUIRED_DEFAULT = false;\n\n  static RELEVANT_DEFAULT = true;\n\n  static CONSTRAINT_DEFAULT = true;\n\n  static TYPE_DEFAULT = 'xs:string';\n\n  static get ACTION_ELEMENTS() {\n    return [\n      'FX-DELETE',\n      'FX-DISPATCH',\n      'FX-INSERT',\n      'FX-LOAD',\n      'FX-MESSAGE',\n      'FX-REBUILD',\n      'FX-RECALCULATE',\n      'FX-REFRESH',\n      'FX-RENEW',\n      'FX-REPLACE',\n      'FX-RESET',\n      'FX-RETAIN',\n      'FX-RETURN',\n      'FX-REVALIDATE',\n      'FX-SEND',\n      'FX-SETFOCUS',\n      'FX-SETINDEX',\n      'FX-SETVALUE',\n      'FX-TOGGLE',\n      'FX-UPDATE',\n    ];\n  }\n\n  static get XFORMS_NAMESPACE_URI() {\n    // todo: should be centralized somewhere as constant. Exists in several? places\n    return 'http://www.w3.org/2002/xforms';\n  }\n\n  static isActionElement(elementName) {\n    return Fore.ACTION_ELEMENTS.includes(elementName);\n  }\n\n  static get UI_ELEMENTS() {\n    return [\n      'FX-ALERT',\n      'FX-CONTROL',\n      'FX-BUTTON',\n      'FX-CONTROL',\n      'FX-DIALOG',\n      'FX-FILENAME',\n      'FX-MEDIATYPE',\n      'FX-GROUP',\n      'FX-HINT',\n      'FX-INPUT',\n      'FX-ITEMSET',\n      'FX-LABEL',\n      'FX-OUTPUT',\n      'FX-RANGE',\n      'FX-REPEAT',\n      'FX-REPEATITEM',\n      'FX-SWITCH',\n      'FX-SECRET',\n      'FX-SELECT',\n      'FX-SUBMIT',\n      'FX-TEXTAREA',\n      'FX-TRIGGER',\n      'FX-UPLOAD',\n    ];\n  }\n\n  static isUiElement(elementName) {\n    const found = Fore.UI_ELEMENTS.includes(elementName);\n    if (found) {\n      // console.log('_isUiElement ', found);\n    }\n    return Fore.UI_ELEMENTS.includes(elementName);\n  }\n\n  static async refreshChildren(startElement) {\n    const refreshed = new Promise(resolve => {\n      const { children } = startElement;\n      if (children) {\n        Array.from(children).forEach(element => {\n          if (Fore.isUiElement(element.nodeName) && typeof element.refresh === 'function') {\n            element.refresh();\n          } else if (element.nodeName.toUpperCase() !== 'FX-MODEL') {\n            Fore.refreshChildren(element);\n          }\n        });\n      }\n      resolve('done');\n    });\n\n    return refreshed;\n  }\n\n  static isRepeated(element) {\n    return element.closest('fx-repeatitem') !== null;\n  }\n\n  static getRepeatTarget(element, id) {\n    const repeatContextItem = element.closest('fx-repeatitem');\n    const target = repeatContextItem.querySelector(`#${id}`);\n    return target;\n  }\n\n  /**\n   * returns the proper content-type for instance.\n   *\n   * @param instance an fx-instance element\n   * @returns {string|null}\n   */\n  static getContentType(instance, method) {\n    if (method === 'urlencoded-post') {\n      return 'application/x-www-form-urlencoded; charset=UTF-8';\n    }\n    if (instance.type === 'xml') {\n      return 'application/xml; charset=UTF-8';\n    }\n    if (instance.type === 'json') {\n      return 'application/json';\n    }\n    console.warn('content-type unknown ', instance.type);\n    return null;\n  }\n\n  /**\n   * clear all text nodes and attribute values to get a 'clean' template.\n   * @param n\n   * @private\n   */\n  /*\n    static clear(n) {\n      n.textContent = '';\n      if (n.hasAttributes()) {\n        const attrs = n.attributes;\n        for (let i = 0; i < attrs.length; i+= 1) {\n          attrs[i].value = '';\n        }\n      }\n      const { children } = n;\n      for (let i = 0; i < children.length; i+= 1) {\n        Fore.clear(children[i]);\n      }\n    }\n  */\n}\n","import {\n  evaluateXPath as fxEvaluateXPath,\n  evaluateXPathToFirstNode as fxEvaluateXPathToFirstNode,\n  evaluateXPathToNodes as fxEvaluateXPathToNodes,\n  evaluateXPathToBoolean as fxEvaluateXPathToBoolean,\n  evaluateXPathToString as fxEvaluateXPathToString,\n  evaluateXPathToNumber as fxEvaluateXPathToNumber,\n  registerCustomXPathFunction,\n  registerXQueryModule,\n} from 'fontoxpath';\n\nconst XFORMS_NAMESPACE_URI = 'http://www.w3.org/2002/xforms';\n\n/**\n * @param id as string\n * @return instance data for given id serialized to string.\n */\nregisterCustomXPathFunction(\n  { namespaceURI: XFORMS_NAMESPACE_URI, localName: 'log' },\n  ['xs:string?'],\n  'xs:string?',\n  (dynamicContext, string) => {\n    const { formElement } = dynamicContext.currentContext;\n    const instance = formElement.querySelector(`fx-instance[id=${string}]`);\n    if (instance) {\n      const def = new XMLSerializer().serializeToString(instance.getDefaultContext());\n      return def;\n    }\n    return null;\n  },\n);\n\nfunction buildTree(tree, data) {\n  if (!data) return;\n  if (data.nodeType === Node.ELEMENT_NODE) {\n    if (data.children) {\n      const details = document.createElement('details');\n      details.setAttribute('data-path', data.nodeName);\n      const summary = document.createElement('summary');\n\n      let display = ` <${data.nodeName}`;\n      Array.from(data.attributes).forEach(attr => {\n        display += ` ${attr.nodeName}=\"${attr.nodeValue}\"`;\n      });\n\n      let contents;\n      if (\n        data.firstChild &&\n        data.firstChild.nodeType === Node.TEXT_NODE &&\n        data.firstChild.data.trim() !== ''\n      ) {\n        // console.log('whoooooooooopp');\n        contents = data.firstChild.nodeValue;\n        display += `>${contents}</${data.nodeName}>`;\n      } else {\n        display += '>';\n      }\n      summary.textContent = display;\n\n      details.appendChild(summary);\n      if (data.childElementCount !== 0) {\n        details.setAttribute('open', 'open');\n      } else {\n        summary.setAttribute('style', 'list-style:none;');\n      }\n      tree.appendChild(details);\n\n      Array.from(data.children).forEach(child => {\n        // if(child.nodeType === Node.ELEMENT_NODE){\n        // child.parentNode.appendChild(buildTree(child));\n        buildTree(details, child);\n        // }\n      });\n    }\n  } /* else if(data.nodeType === Node.ATTRIBUTE_NODE){\n        //create span for now\n        // const span = document.createElement('span');\n        // span.style.background = 'grey';\n        // span.textContent = data.value;\n        // tree.appendChild(span);\n        tree.setAttribute(data.nodeName,data.value);\n    }else {\n        tree.textContent = data;\n    } */\n\n  // return tree;\n}\n\nregisterCustomXPathFunction(\n  { namespaceURI: XFORMS_NAMESPACE_URI, localName: 'logtree' },\n  ['xs:string?'],\n  'element()?',\n  (dynamicContext, string) => {\n    const { formElement } = dynamicContext.currentContext;\n    const instance = formElement.querySelector(`fx-instance[id=${string}]`);\n    if (instance) {\n      // const def = new XMLSerializer().serializeToString(instance.getDefaultContext());\n      // const def = JSON.stringify(instance.getDefaultContext());\n\n      const tree = document.createElement('div');\n      tree.setAttribute('class', 'logtree');\n      // const datatree = buildTree(tree,instance.getDefaultContext());\n      // return tree.appendChild(datatree);\n      // return  buildTree(root,instance.getDefaultContext());;\n      const form = dynamicContext.currentContext.formElement;\n      const logtree = form.querySelector('.logtree');\n      if (logtree) {\n        logtree.parentNode.removeChild(logtree);\n      }\n      form.appendChild(buildTree(tree, instance.getDefaultContext()));\n    }\n    return null;\n  },\n);\n\nconst xhtmlNamespaceResolver = prefix => {\n  if (!prefix) {\n    return 'http://www.w3.org/1999/xhtml';\n  }\n  return undefined;\n};\n\nconst instance = (dynamicContext, string) => {\n  // Spec: https://www.w3.org/TR/xforms-xpath/#The_XForms_Function_Library#The_instance.28.29_Function\n  // TODO: handle no string passed (null will be passed instead)\n\n  const formElement = fxEvaluateXPathToFirstNode(\n    'ancestor-or-self::fx-fore',\n    dynamicContext.currentContext.formElement,\n    null,\n    null,\n    { namespaceResolver: xhtmlNamespaceResolver },\n  );\n\n  // console.log('fnInstance dynamicContext: ', dynamicContext);\n  // console.log('fnInstance string: ', string);\n\n  const inst = string\n    ? formElement.querySelector(`fx-instance[id=${string}]`)\n    : formElement.querySelector(`fx-instance`);\n\n  // const def = instance.getInstanceData();\n  if (inst) {\n    const def = inst.getDefaultContext();\n    // console.log('target instance root node: ', def);\n\n    return def;\n  }\n  return null;\n};\n\nregisterCustomXPathFunction(\n  { namespaceURI: XFORMS_NAMESPACE_URI, localName: 'index' },\n  ['xs:string?'],\n  'xs:integer?',\n  (dynamicContext, string) => {\n    const { formElement } = dynamicContext.currentContext;\n    const repeat = string ? formElement.querySelector(`fx-repeat[id=${string}]`) : null;\n\n    // const def = instance.getInstanceData();\n    if (repeat) {\n      return repeat.getAttribute('index');\n    }\n    return 1;\n  },\n);\n\n// Note that this is not to spec. The spec enforces elements to be returned from the\n// instance. However, we allow instances to actually be JSON!\nregisterCustomXPathFunction(\n  { namespaceURI: XFORMS_NAMESPACE_URI, localName: 'instance' },\n  [],\n  'item()?',\n  domFacade => instance(domFacade, null),\n);\n\nregisterCustomXPathFunction(\n  { namespaceURI: XFORMS_NAMESPACE_URI, localName: 'instance' },\n  ['xs:string?'],\n  'item()?',\n  instance,\n);\n\nregisterCustomXPathFunction(\n  { namespaceURI: XFORMS_NAMESPACE_URI, localName: 'depends' },\n  ['node()*'],\n  'item()?',\n  (dynamicContext, nodes) =>\n    // console.log('depends on : ', nodes[0]);\n    nodes[0],\n);\n\nregisterCustomXPathFunction(\n  { namespaceURI: XFORMS_NAMESPACE_URI, localName: 'event' },\n  ['xs:string?'],\n  'item()?',\n  (dynamicContext, arg) => {\n    const payload = dynamicContext.currentContext.variables[arg];\n    if (payload.nodeType) {\n      console.log('got some node as js object');\n    }\n\n    return dynamicContext.currentContext.variables[arg];\n  },\n);\n\n// Implement the XForms standard functions here.\nregisterXQueryModule(`\n    module namespace xf=\"${XFORMS_NAMESPACE_URI}\";\n\n    declare %public function xf:boolean-from-string($str as xs:string) as xs:boolean {\n        lower-case($str) = \"true\" or $str = \"1\"\n    };\n`);\n\n// How to run XQUERY:\n/**\n registerXQueryModule(`\n module namespace my-custom-namespace = \"my-custom-uri\";\n (:~\n Insert attribute somewhere\n ~:)\n declare %public %updating function my-custom-namespace:do-something ($ele as element()) as xs:boolean {\n\tif ($ele/@done) then false() else\n\t(insert node\n\tattribute done {\"true\"}\n\tinto $ele, true())\n};\n `)\n // At some point:\n const contextNode = null;\n const pendingUpdatesAndXdmValue = evaluateUpdatingExpressionSync('ns:do-something(.)', contextNode, null, null, {moduleImports: {'ns': 'my-custom-uri'}})\n\n console.log(pendingUpdatesAndXdmValue.xdmValue); // this is true or false, see function\n\n executePendingUpdateList(pendingUpdatesAndXdmValue.pendingUpdateList, null, null, null);\n */\n\n/**\n * Implementation of the functionNameResolver passed to FontoXPath to\n * redirect function resolving for unprefixed functions to either the fn or the xf namespace\n */\n// eslint-disable-next-line no-unused-vars\nfunction functionNameResolver({ prefix, localName }, _arity) {\n  switch (localName) {\n    // TODO: put the full XForms library functions set here\n    case 'base64encode':\n    case 'boolean-from-string':\n    case 'depends':\n    case 'event':\n    case 'index':\n    case 'instance':\n    case 'log':\n    case 'logtree':\n      return { namespaceURI: XFORMS_NAMESPACE_URI, localName };\n    default:\n      if (prefix === '' || prefix === 'fn') {\n        return { namespaceURI: 'http://www.w3.org/2005/xpath-functions', localName };\n      }\n      if (prefix === 'local') {\n        return { namespaceURI: 'http://www.w3.org/2005/xquery-local-functions', localName };\n      }\n      return null;\n  }\n}\n\n/**\n * Resolve a namespace. Needs a namespace prefix and the element that is most closely related to the\n * XPath in which the namespace is being resolved. The prefix will be resolved by using the\n * ancestry of said element.\n *\n * It has two ways of doing so:\n *\n * - If the prefix is defined in an `xmlns:XXX=\"YYY\"` namespace declaration, it will return 'YYY'.\n * - If the prefix is the empty prefix and there is an `xpath-default-namespace=\"YYY\"` attribute in the\n * - ancestry, that attribute will be used and 'YYY' will be returned\n *\n * @param  {Node}  contextElement  The element that is most closely related with the XPath in which this prefix is resolved.\n * @param  {string}   prefix          The prefix to resolve\n */\nfunction resolveNamespacePrefix(contextElement, prefix) {\n  if (prefix === 'xhtml') {\n    return 'http://www.w3.org/1999/xhtml';\n  }\n\n  if (prefix === '') {\n    return (\n      fxEvaluateXPathToString(\n        'ancestor-or-self::*/@xpath-default-namespace[last()]',\n        contextElement,\n      ) || null\n    );\n  }\n\n  // Note: ideally we should use Node#lookupNamespaceURI. However, the nodes we are passed are\n  // XML. The best we can do is emulate the `xmlns:xxx` namespace declarations by regarding them as\n  // attributes. Which they technically ARE NOT!\n\n  const result = fxEvaluateXPathToString(\n    'ancestor-or-self::*/@*[name() = \"xmlns:\" || $prefix][last()]',\n    contextElement,\n    null,\n    { prefix },\n  );\n\n  console.log('result', result);\n  return result;\n}\n\n/**\n * Evaluate an XPath to _any_ type. When possible, prefer to use any other function to ensure the\n * type of the output is more predictable.\n *\n * @param  {string} xpath  The XPath to run\n * @param  {Node} contextNode The start of the XPath\n * @param  {{parentNode}|ForeElementMixin} formElement  The form element associated to the XPath\n */\nexport function evaluateXPath(xpath, contextNode, formElement, variables = {}) {\n  return fxEvaluateXPath(xpath, contextNode, null, variables, 'xs:anyType', {\n    currentContext: { formElement, variables },\n    moduleImports: {\n      xf: XFORMS_NAMESPACE_URI,\n    },\n    functionNameResolver,\n    namespaceResolver: prefix => resolveNamespacePrefix(formElement, prefix),\n  });\n}\n\n/**\n * Evaluate an XPath to the first Node\n *\n * @param  {string} xpath  The XPath to run\n * @param  {Node} contextNode The start of the XPath\n * @param  {Node} formElement  The form element associated to the XPath\n * @return {Node}  The first node found by the XPath\n */\nexport function evaluateXPathToFirstNode(xpath, contextNode, formElement) {\n  return fxEvaluateXPathToFirstNode(\n    xpath,\n    contextNode,\n    null,\n    {},\n    {\n      namespaceResolver: prefix => resolveNamespacePrefix(formElement, prefix),\n      defaultFunctionNamespaceURI: XFORMS_NAMESPACE_URI,\n      moduleImports: {\n        xf: XFORMS_NAMESPACE_URI,\n      },\n      currentContext: { formElement },\n    },\n  );\n}\n\n/**\n * Evaluate an XPath to all nodes\n *\n * @param  {string} xpath  The XPath to run\n * @param  {Node} contextNode The start of the XPath\n * @param  {Node} formElement  The form element associated to the XPath\n * @return {Node[]}  All nodes\n */\nexport function evaluateXPathToNodes(xpath, contextNode, formElement) {\n  return fxEvaluateXPathToNodes(\n    xpath,\n    contextNode,\n    null,\n    {},\n    {\n      currentContext: { formElement },\n      functionNameResolver,\n      moduleImports: {\n        xf: XFORMS_NAMESPACE_URI,\n      },\n      namespaceResolver: prefix => resolveNamespacePrefix(formElement, prefix),\n    },\n  );\n}\n\n/**\n * Evaluate an XPath to a boolean\n *\n * @param  {string} xpath  The XPath to run\n * @param  {Node} contextNode The start of the XPath\n * @param  {Node} formElement  The form element associated to the XPath\n * @return {boolean}\n */\nexport function evaluateXPathToBoolean(xpath, contextNode, formElement) {\n  return fxEvaluateXPathToBoolean(\n    xpath,\n    contextNode,\n    null,\n    {},\n    {\n      currentContext: { formElement },\n      functionNameResolver,\n      moduleImports: {\n        xf: XFORMS_NAMESPACE_URI,\n      },\n      namespaceResolver: prefix => resolveNamespacePrefix(formElement, prefix),\n    },\n  );\n}\n\n/**\n * Evaluate an XPath to a string\n *\n * @param  {string}     xpath             The XPath to run\n * @param  {Node}       contextNode       The start of the XPath\n * @param  {Node}       formElement       The form element associated to the XPath\n * @param  {DomFacade}  [domFacade=null]  A DomFacade is used in bindings to intercept DOM\n * access. This is used to determine dependencies between bind elements.\n * @param  {Node}       formElement       The element where the XPath is defined: used for namespace resolving\n * @return {string}\n */\nexport function evaluateXPathToString(\n  xpath,\n  contextNode,\n  formElement,\n  domFacade = null,\n  namespaceReferenceNode = formElement,\n) {\n  return fxEvaluateXPathToString(\n    xpath,\n    contextNode,\n    domFacade,\n    {},\n\n    {\n      currentContext: { formElement },\n      functionNameResolver,\n      moduleImports: {\n        xf: XFORMS_NAMESPACE_URI,\n      },\n      namespaceResolver: prefix => resolveNamespacePrefix(namespaceReferenceNode, prefix),\n    },\n  );\n}\n\n/**\n * Evaluate an XPath to a number\n *\n * @param  {string}     xpath             The XPath to run\n * @param  {Node}       contextNode       The start of the XPath\n * @param  {Node}       formElement       The form element associated to the XPath\n * @param  {DomFacade}  [domFacade=null]  A DomFacade is used in bindings to intercept DOM\n * @param  {Node}       formElement       The element where the XPath is defined: used for namespace resolving\n * access. This is used to determine dependencies between bind elements.\n * @return {Number}\n */\nexport function evaluateXPathToNumber(\n  xpath,\n  contextNode,\n  formElement,\n  domFacade = null,\n  namespaceReferenceNode = formElement,\n) {\n  return fxEvaluateXPathToNumber(\n    xpath,\n    contextNode,\n    domFacade,\n    {},\n    {\n      currentContext: { formElement },\n      functionNameResolver,\n      moduleImports: {\n        xf: XFORMS_NAMESPACE_URI,\n      },\n      namespaceResolver: prefix => resolveNamespacePrefix(namespaceReferenceNode, prefix),\n    },\n  );\n}\n\n/**\n * @param input as string\n * @return {string}\n */\nregisterCustomXPathFunction(\n  { namespaceURI: XFORMS_NAMESPACE_URI, localName: 'base64encode' },\n  ['xs:string?'],\n  'xs:string?',\n  (dynamicContext, string) => btoa(string),\n);\n","import { Fore } from './fore.js';\nimport { evaluateXPathToFirstNode } from './xpath-evaluation.js';\n\n/**\n * Container for data instances.\n *\n * Offers several ways of loading data from either inline content or via 'src' attribute which will use the fetch\n * API to resolve data.\n */\nexport class FxInstance extends HTMLElement {\n  constructor() {\n    super();\n    this.model = this.parentNode;\n    this.attachShadow({ mode: 'open' });\n  }\n\n  connectedCallback() {\n    // console.log('connectedCallback ', this);\n    if (this.hasAttribute('src')) {\n      this.src = this.getAttribute('src');\n    }\n\n    if (this.hasAttribute('id')) {\n      this.id = this.getAttribute('id');\n    } else {\n      this.id = 'default';\n    }\n\n    if (this.hasAttribute('type')) {\n      this.type = this.getAttribute('type');\n    } else {\n      this.type = 'xml';\n    }\n    const style = `\n            :host {\n                display: none;\n            }\n            :host * {\n                display:none;\n            }\n            ::slotted(*){\n                display:none;\n            }\n        `;\n\n    const html = `\n        `;\n    this.shadowRoot.innerHTML = `\n            <style>\n                ${style}\n            </style>\n            ${html}\n        `;\n  }\n\n  /**\n   * Is called by fx-model during initialization phase (model-construct)\n   * @returns {Promise<void>}\n   */\n  async init() {\n    // console.log('fx-instance init');\n    await this._initInstance().then(() => {\n      this.dispatchEvent(\n        new CustomEvent('instance-loaded', {\n          composed: true,\n          bubbles: true,\n          detail: { instance: this },\n        }),\n      );\n      return this;\n    });\n  }\n\n  evalXPath(xpath) {\n    const formElement = this.parentElement.parentElement;\n    const result = evaluateXPathToFirstNode(xpath, this.getDefaultContext(), formElement);\n    return result;\n  }\n\n  /**\n   * returns the current instance data\n   *\n   * @returns {Document | T | any}\n   */\n  getInstanceData() {\n    if (!this.instanceData) {\n      this._createInstanceData();\n    }\n    return this.instanceData;\n  }\n\n  setInstanceData(data) {\n    if (!data) {\n      this._createInstanceData();\n      return;\n    }\n    this.instanceData = data;\n  }\n\n  /**\n   * return the default context (root node of respective instance) for XPath evalution.\n   *\n   * @returns {Document|T|any|Element}\n   */\n  getDefaultContext() {\n    // console.log('getDefaultContext ', this.instanceData.firstElementChild);\n    if (this.type === 'xml') {\n      return this.instanceData.firstElementChild;\n    }\n    return this.instanceData;\n  }\n\n  /**\n   * does the actual loading of data. Handles inline data, data loaded via fetch() or data constructed from\n   * querystring.\n   *\n   * @returns {Promise<void>}\n   * @private\n   */\n  async _initInstance() {\n    if (this.src === '#querystring') {\n      /*\n       * generate XML data from URL querystring\n       * todo: there's no variant to generate JSON yet\n       */\n      // eslint-disable-next-line no-restricted-globals\n      const query = new URLSearchParams(location.search);\n      const doc = new DOMParser().parseFromString('<data></data>', 'application/xml');\n      const root = doc.firstElementChild;\n      for (const p of query) {\n        const newNode = doc.createElement(p[0]);\n        newNode.appendChild(doc.createTextNode(p[1]));\n        root.appendChild(newNode);\n      }\n      this.instanceData = doc;\n      // this.instanceData.firstElementChild.setAttribute('id', this.id);\n      // resolve('done');\n    } else if (this.src) {\n      await this._loadData();\n    } else if (this.childNodes.length !== 0) {\n      this._useInlineData();\n    }\n  }\n\n  _createInstanceData() {\n    if (this.type === 'xml') {\n      const doc = new DOMParser().parseFromString('<data></data>', 'application/xml');\n      this.instanceData = doc;\n    }\n    if (this.type === 'json') {\n      this.instanceData = {};\n    }\n  }\n\n  async _loadData() {\n    const url = `${this.src}`;\n    const contentType = Fore.getContentType(this, 'get');\n\n    await fetch(url, {\n      method: 'GET',\n      mode: 'cors',\n      credentials: 'include',\n      headers: {\n        'Content-Type': contentType,\n      },\n    })\n      .then(response => {\n        const responseContentType = response.headers.get('content-type').toLowerCase();\n        console.log('********** responseContentType *********', responseContentType);\n        if (responseContentType.startsWith('text/plain')) {\n          // console.log(\"********** inside  res plain *********\");\n          return response.text();\n        }\n        if (responseContentType.startsWith('application/json')) {\n          // console.log(\"********** inside res json *********\");\n          return response.json();\n        }\n        if (responseContentType.startsWith('application/xml')) {\n          return response.text().then(result => {\n            console.log('xml ********', result);\n            return new DOMParser().parseFromString(result, 'application/xml');\n          });\n        }\n        return 'done';\n      })\n      .then(data => {\n        this.instanceData = data;\n        console.log('instanceData loaded: ', this.instanceData);\n      })\n      .catch(error => {\n        throw new Error(`failed loading data ${error}`);\n      });\n  }\n\n  _getContentType() {\n    if (this.type === 'xml') {\n      return 'application/xml';\n    }\n    if (this.type === 'json') {\n      return 'application/json';\n    }\n    console.warn('content-type unknown ', this.type);\n    return null;\n  }\n\n  _useInlineData() {\n    if (this.type === 'xml') {\n      // console.log('innerHTML ', this.innerHTML);\n      const instanceData = new DOMParser().parseFromString(this.innerHTML, 'application/xml');\n\n      console.log('fx-instance init id:', this.id);\n      this.instanceData = instanceData;\n      // console.log('instanceData ', this.instanceData);\n      // console.log('instanceData ', this.instanceData.firstElementChild);\n\n      console.log('fx-instance data: ', this.instanceData);\n      // this.instanceData.firstElementChild.setAttribute('id', this.id);\n      // todo: move innerHTML out to shadowDOM (for later reset)\n    } else if (this.type === 'json') {\n      this.instanceData = JSON.parse(this.textContent);\n    } else {\n      console.warn('unknow type for data ', this.type);\n    }\n  }\n\n  _handleResponse() {\n    console.log('_handleResponse ');\n    const ajax = this.shadowRoot.getElementById('loader');\n    const instanceData = new DOMParser().parseFromString(ajax.lastResponse, 'application/xml');\n    this.instanceData = instanceData;\n    console.log('data: ', this.instanceData);\n  }\n\n  _handleError() {\n    const loader = this.shadowRoot.getElementById('loader');\n    console.log('_handleResponse ', loader.lastError);\n  }\n}\ncustomElements.define('fx-instance', FxInstance);\n","/**\n * Class for holding ModelItem facets.\n *\n * A ModelItem annotates nodes that are referred by a fx-bind element with facets for calculation and validation.\n *\n * Each bound node in an instance has exactly one ModelItem associated with it.\n */\nexport class ModelItem {\n  /**\n   *\n   * @param {path} calculated normalized path expression linking to data\n   * @param {ref} ref relative binding expression\n   * @param {*} isReadonly - boolean to signal readonly/readwrite state\n   * @param {*} relevant - boolean to signal relevant/non-relevant state\n   * @param {*} required - boolean to signal required/optional state\n   * @param {*} required - boolean boolean to signal valid/invalid state\n   * @param {*} type - string expression to set a datatype\n   * @param {*} node - the node the 'ref' expression is referring to\n   * @param {*} bind - the fx-bind element having created this modelItem\n   */\n  constructor(path, ref, readonly, relevant, required, constraint, type, node, bind) {\n    this.path = path;\n    this.ref = ref;\n    this.constraint = constraint;\n    this.readonly = readonly;\n    this.relevant = relevant;\n    this.required = required;\n    this.type = type;\n    this.node = node;\n    this.bind = bind;\n    this.changed = false;\n    this.alerts = [];\n    // this.value = this._getValue();\n  }\n\n  /*\n    get ref(){\n        return this.bind.ref;\n    }\n*/\n\n  get value() {\n    if (!this.node.nodeType) return this.node;\n\n    if (this.node.nodeType === Node.ATTRIBUTE_NODE) {\n      return this.node.nodeValue;\n    }\n    return this.node.textContent;\n  }\n\n  set value(newVal) {\n    console.log('modelitem.setvalue oldVal', this.value);\n    console.log('modelitem.setvalue newVal', newVal);\n\n    if (newVal.nodeType === Node.DOCUMENT_NODE) {\n      // this.node.replaceWith(newVal.firstElementChild);\n      this.node.appendChild(newVal.firstElementChild);\n    } else if (newVal.nodeType === Node.ELEMENT_NODE) {\n      // this.node.replaceWith(newVal);\n      this.node.appendChild(newVal);\n    } else if (this.node.nodeType === Node.ATTRIBUTE_NODE) {\n      this.node.nodeValue = newVal;\n    } else {\n      this.node.textContent = newVal;\n    }\n  }\n\n  addAlert(alert) {\n    this.alerts.push(alert);\n  }\n\n  cleanAlerts() {\n    this.alerts = [];\n  }\n}\n","import { DepGraph } from './dep_graph.js';\nimport { Fore } from './fore.js';\nimport './fx-instance.js';\nimport { ModelItem } from './modelitem.js';\nimport { evaluateXPath, evaluateXPathToBoolean } from './xpath-evaluation.js';\nimport { XPathUtil } from './xpath-util.js';\n\n/**\n * @ts-check\n */\nexport class FxModel extends HTMLElement {\n  constructor() {\n    super();\n    // this.id = '';\n\n    this.instances = [];\n    this.modelItems = [];\n    this.defaultContext = {};\n\n    // this.mainGraph = new DepGraph(false);\n    this.inited = false;\n    this.modelConstructed = false;\n    this.attachShadow({ mode: 'open' });\n  }\n\n  get formElement() {\n    return this.parentElement;\n  }\n\n  connectedCallback() {\n    // console.log('connectedCallback ', this);\n    this.shadowRoot.innerHTML = `\n            <slot></slot>\n        `;\n\n    this.addEventListener('model-construct-done', e => {\n      this.modelConstructed = true;\n      // console.log('model-construct-done fired ', this.modelConstructed);\n      console.log('model-construct-done fired ', e.detail.model.instances);\n    });\n\n    // logging\n  }\n\n  static lazyCreateModelItem(model, ref, node) {\n    // console.log('lazyCreateModelItem ', node);\n\n    let targetNode = {};\n    if (node === null || node === undefined) return null;\n    if (node.nodeType === node.TEXT_NODE) {\n      // const parent = node.parentNode;\n      // console.log('PARENT ', parent);\n      targetNode = node.parentNode;\n    } else {\n      targetNode = node;\n    }\n\n    // const path = fx.evaluateXPath('path()',node);\n    let path;\n    if (node.nodeType) {\n      path = XPathUtil.getPath(node);\n    } else {\n      path = null;\n      targetNode = node;\n    }\n    // const path = XPathUtil.getPath(node);\n\n    // ### intializing ModelItem with default values (as there is no <fx-bind> matching for given ref)\n    const mi = new ModelItem(\n      path,\n      ref,\n      Fore.READONLY_DEFAULT,\n      Fore.RELEVANT_DEFAULT,\n      Fore.REQUIRED_DEFAULT,\n      Fore.CONSTRAINT_DEFAULT,\n      Fore.TYPE_DEFAULT,\n      targetNode,\n      this,\n    );\n\n    // console.log('new ModelItem is instanceof ModelItem ', mi instanceof ModelItem);\n    model.registerModelItem(mi);\n    return mi;\n  }\n\n  modelConstruct() {\n    console.log('### <<<<< dispatching model-construct >>>>>');\n    this.dispatchEvent(new CustomEvent('model-construct', { detail: this }));\n\n    const instances = this.querySelectorAll('fx-instance');\n    if (instances.length > 0) {\n      console.group('init instances');\n      const promises = [];\n      instances.forEach(instance => {\n        promises.push(instance.init());\n      });\n\n      Promise.all(promises).then(() => {\n        this.instances = Array.from(instances);\n        console.log('_modelConstruct this.instances ', this.instances);\n        this.updateModel();\n        this.inited = true;\n\n        console.log('### <<<<< dispatching model-construct-done >>>>>');\n        this.dispatchEvent(\n          new CustomEvent('model-construct-done', {\n            composed: true,\n            bubbles: true,\n            detail: { model: this },\n          }),\n        );\n      });\n      console.groupEnd();\n    } else {\n      // ### if there's no instance one will created\n      this.dispatchEvent(\n        new CustomEvent('model-construct-done', {\n          composed: true,\n          bubbles: true,\n          detail: { model: this },\n        }),\n      );\n    }\n    this.inited = true;\n  }\n\n  registerModelItem(modelItem) {\n    // console.log('ModelItem registered ', modelItem);\n    this.modelItems.push(modelItem);\n  }\n\n  /**\n   * update action triggering the update cycle\n   */\n  updateModel() {\n    this.rebuild();\n    this.recalculate();\n    this.revalidate();\n  }\n\n  rebuild() {\n    console.group('### rebuild');\n\n    this.mainGraph = new DepGraph(false);\n    this.modelItems = [];\n\n    // trigger recursive initialization of the fx-bind elements\n    const binds = this.querySelectorAll('fx-model > fx-bind');\n    binds.forEach(bind => {\n      bind.init(this);\n    });\n\n    // console.log(`dependencies of a `, this.mainGraph.dependenciesOf(\"/Q{}data[1]/Q{}a[1]:required\"));\n    // console.log(`dependencies of b `, this.mainGraph.dependenciesOf(\"/Q{}data[1]/Q{}b[1]:required\"));\n    console.log(`rebuild mainGraph`, this.mainGraph);\n    console.log(`rebuild mainGraph calc order`, this.mainGraph.overallOrder());\n    /*\n    console.log(\n      `rebuild finished with modelItems ${this.modelItems.length} item(s)`,\n      this.modelItems,\n    );\n*/\n    console.groupEnd();\n  }\n\n  /**\n   * recalculation of all modelItems. Uses dependency graph to determine order of computation.\n   *\n   * todo: use 'changed' flag on modelItems to determine subgraph for recalculation. Flag already exists but is not used.\n   */\n  recalculate() {\n    console.group('### recalculate');\n    console.log('recalculate instances ', this.instances);\n\n    const v = this.mainGraph.overallOrder();\n    v.forEach(path => {\n      console.log('recalculating path ', path);\n\n      const node = this.mainGraph.getNodeData(path);\n      // console.log('recalculating node ', node);\n      const modelItem = this.getModelItem(node);\n      // console.log('modelitem ', modelItem);\n\n      if (modelItem && path.includes(':')) {\n        const property = path.split(':')[1];\n        if (property) {\n          if (property === 'calculate') {\n            const expr = modelItem.bind[property];\n            const compute = evaluateXPath(expr, modelItem.node, this);\n            modelItem.value = compute;\n          } else if (property !== 'constraint' && property !== 'type') {\n            console.log('recalculating property ', property);\n\n            const expr = modelItem.bind[property];\n            if (expr) {\n              console.log('recalc expr: ', expr);\n              const compute = evaluateXPathToBoolean(expr, modelItem.node, this);\n              modelItem[property] = compute;\n              console.log(`modelItem '${property}'='${expr}' computed`, modelItem.required);\n            }\n          }\n        }\n      }\n    });\n    console.log(\n      `recalculate finished with modelItems ${this.modelItems.length} item(s)`,\n      this.modelItems,\n    );\n    console.groupEnd();\n  }\n\n  /**\n   * Iterates all modelItems to calculate the validation status.\n   *\n   * Model alerts are given on 'fx-bind' elements as either attribute `alert` or as `fx-alert` child elements.\n   *\n   * During model-construct all model alerts are added to the modelItem if any\n   *\n   * to revalidate:\n   * Gets the `constraint` attribute declaration from modelItem.bind\n   * Computes the XPath to a Boolean\n   * Updates the modelItem.constraint property\n   *\n   * todo: type checking\n   * todo: run browser validation API\n   *\n   */\n  revalidate() {\n    console.group('### revalidate');\n\n    let valid = true;\n    this.modelItems.forEach(modelItem => {\n      // console.log('validating node ', modelItem.node);\n\n      const { bind } = modelItem;\n      if (bind) {\n        /*\n        todo: investigate why bind is an element when created in fx-bind.init() and an fx-bind object when\n          created lazily.\n        */\n        if (typeof bind.hasAttribute === 'function' && bind.hasAttribute('constraint')) {\n          const constraint = bind.getAttribute('constraint');\n          if (constraint) {\n            const compute = evaluateXPathToBoolean(constraint, modelItem.node, this);\n            console.log('modelItem validity computed: ', compute);\n            modelItem.constraint = compute;\n            if (!compute) valid = false;\n            // ### alerts are added only once during model-construct. Otherwise they would add up in each run of revalidate()\n            if (!this.modelConstructed) {\n              // todo: get alert from attribute or child element\n              const alert = bind.getAlert();\n              if (alert) {\n                modelItem.addAlert(alert);\n              }\n            }\n          }\n        }\n      }\n    });\n    console.log('modelItems after revalidate: ', this.modelItems);\n    console.groupEnd();\n    return valid;\n  }\n\n  /**\n   *\n   * @param node\n   * @returns {ModelItem}\n   */\n  getModelItem(node) {\n    return this.modelItems.find(m => m.node === node);\n  }\n\n  /**\n   * get the default evaluation context for this model.\n   * @returns {Element} the\n   */\n  getDefaultContext() {\n    return this.instances[0].getDefaultContext();\n  }\n\n  getDefaultInstance() {\n    return this.instances[0];\n  }\n\n  getDefaultInstanceData() {\n    console.log('default instance data ', this.instances[0].instanceData);\n    return this.instances[0].instanceData;\n  }\n\n  getInstance(id) {\n    // console.log('getInstance ', id);\n    // console.log('instances ', this.instances);\n    // console.log('instances array ',Array.from(this.instances));\n\n    const instArray = Array.from(this.instances);\n    return instArray.find(inst => inst.id === id);\n  }\n\n  evalBinding(bindingExpr) {\n    // console.log('MODEL.evalBinding ', bindingExpr);\n    // default context of evaluation is always the default instance\n    const result = this.instances[0].evalXPath(bindingExpr);\n    return result;\n  }\n}\n\ncustomElements.define('fx-model', FxModel);\n","import { evaluateXPathToFirstNode } from './xpath-evaluation.js';\n\nimport { XPathUtil } from './xpath-util.js';\n\nfunction _getParentElement(node) {\n  if (node.nodeType === Node.ATTRIBUTE_NODE) {\n    return node.ownerElement;\n  }\n  return node.parentNode;\n}\n\nfunction _getForeContext(node) {\n  return node.closest('fx-fore');\n}\n\nfunction _getModelInContext(node) {\n  // const ownerForm = node.closest('fx-fore');\n  const ownerForm = _getForeContext(node);\n  return ownerForm.getModel();\n}\n\nfunction _getInitialContext(node, ref) {\n  const parentBind = node.closest('[ref]');\n\n  if (parentBind !== null) {\n    return parentBind.nodeset;\n  }\n\n  const model = _getModelInContext(node);\n  if (XPathUtil.isAbsolutePath(ref)) {\n    const instanceId = XPathUtil.getInstanceId(ref);\n    return model.getInstance(instanceId).getDefaultContext();\n  }\n  if (model.getDefaultInstance() !== null) {\n    return model.getDefaultInstance().getDefaultContext();\n  }\n  return [];\n}\n\nexport default function getInScopeContext(node, ref) {\n  const parentElement = _getParentElement(node);\n  /*\n  if(parentElement.nodeName.toUpperCase() === 'FX-REPEATITEM'){\n    return parentElement.nodeset;\n  }\n*/\n\n  const repeatItem = parentElement.closest('fx-repeatitem');\n  if (repeatItem) {\n    return repeatItem.nodeset;\n  }\n\n  if (node.nodeType === Node.ELEMENT_NODE && node.hasAttribute('context')) {\n    const initialContext = _getInitialContext(node.parentNode, ref);\n    const contextAttr = node.getAttribute('context');\n    return evaluateXPathToFirstNode(contextAttr, initialContext, _getForeContext(parentElement));\n  }\n  return _getInitialContext(parentElement, ref);\n}\n","import { XPathUtil } from './xpath-util.js';\nimport { FxModel } from './fx-model.js';\nimport {\n  evaluateXPath,\n  evaluateXPathToFirstNode,\n  evaluateXPathToString,\n} from './xpath-evaluation.js';\nimport getInScopeContext from './getInScopeContext.js';\n\nexport const foreElementMixin = superclass =>\n  class ForeElementMixin extends superclass {\n    static get properties() {\n      return {\n        /**\n         * context object for evaluation\n         */\n        context: {\n          type: Object,\n        },\n        /**\n         * the model of this element\n         */\n        model: {\n          type: Object,\n        },\n        /**\n         * XPath binding expression pointing to bound node\n         */\n        ref: {\n          type: String,\n        },\n        /**\n         * The modelitem object associated to the bound node holding the evaluated state.\n         */\n        modelItem: {\n          type: Object,\n        },\n        /**\n         * the node(s) bound by this element\n         */\n        nodeset: {\n          type: Object,\n        },\n      };\n    }\n\n    constructor() {\n      super();\n      this.context = null;\n      this.model = null;\n      this.modelItem = {};\n      this.ref = this.hasAttribute('ref') ? this.getAttribute('ref') : '';\n    }\n\n    getModel() {\n      // console.log('getModel this ', this);\n      if (this.model) {\n        return this.model;\n      }\n      // const ownerForm = this.closest('fx-fore');\n      // const ownerForm = this.getOwnerForm(this);\n      const ownerForm = this.getOwnerForm();\n      return ownerForm.querySelector('fx-model');\n    }\n\n    /**\n     *\n     * @returns {{parentNode}|ForeElementMixin}\n     */\n    getOwnerForm() {\n      let currentElement = this;\n      while (currentElement && currentElement.parentNode) {\n        // console.log('current ', currentElement);\n\n        if (currentElement.nodeName.toUpperCase() === 'FX-FORE') {\n          return currentElement;\n        }\n\n        if (currentElement.parentNode instanceof DocumentFragment) {\n          currentElement = currentElement.parentNode.host;\n        } else {\n          currentElement = currentElement.parentNode;\n        }\n      }\n      return currentElement;\n    }\n\n    /**\n     * evaluation of fx-bind and UiElements differ in details so that each class needs it's own implementation.\n     */\n    evalInContext() {\n      // const inscopeContext = this.getInScopeContext();\n      const inscopeContext = getInScopeContext(this, this.ref);\n      if (!inscopeContext) {\n        console.warn('no in scopeContext for ', this);\n        return;\n      }\n      if (this.ref === '') {\n        this.nodeset = inscopeContext;\n      } else if (Array.isArray(inscopeContext)) {\n        inscopeContext.forEach(n => {\n          if (XPathUtil.isSelfReference(this.ref)) {\n            this.nodeset = inscopeContext;\n          } else {\n            const localResult = evaluateXPathToFirstNode(this.ref, n, null);\n            // console.log('local result: ', localResult);\n            this.nodeset.push(localResult);\n          }\n        });\n      } else {\n        // this.nodeset = fx.evaluateXPathToFirstNode(this.ref, inscopeContext, null, {namespaceResolver: this.namespaceResolver});\n\n        // todo: code below fails - why?\n        const formElement = this.getOwnerForm();\n        if (inscopeContext.nodeType) {\n          this.nodeset = evaluateXPathToFirstNode(this.ref, inscopeContext, formElement);\n        } else {\n          this.nodeset = evaluateXPath(this.ref, inscopeContext, formElement);\n        }\n        // this.nodeset = evaluateXPath(this.ref,inscopeContext,formElement)\n      }\n      // console.log('UiElement evaluated to nodeset: ', this.nodeset);\n    }\n\n    isNotBound() {\n      return !this.hasAttribute('ref');\n    }\n\n    isBound() {\n      return this.hasAttribute('ref');\n    }\n\n    getBindingExpr() {\n      if (this.hasAttribute('ref')) {\n        return this.getAttribute('ref');\n      }\n      // try to get closest parent bind\n      const parent = this.parentNode.closest('[ref]');\n      if (!parent) {\n        return 'instance()'; // the default instance\n      }\n      return parent.getAttribute('ref');\n    }\n\n    getInstance() {\n      if (this.ref.startsWith('instance(')) {\n        const instId = XPathUtil.getInstanceId(this.ref);\n        return this.getModel().getInstance(instId);\n      }\n      return this.getModel().getInstance('default');\n    }\n\n    _getParentBindingElement(start) {\n      if (start.parentNode.host) {\n        const { host } = start.parentNode;\n        if (host.hasAttribute('ref')) {\n          return host;\n        }\n      } else if (start.parentNode) {\n        if (start.parentNode.hasAttribute('ref')) {\n          return this.parentNode;\n        }\n        this._getParentBindingElement(this.parentNode);\n      }\n      return null;\n    }\n\n    getModelItem() {\n      // return this.model.bindingMap.find(m => m.refnode === this.nodeset);\n      // return this.getModel().bindingMap.find(m => m.refnode === this.nodeset);\n\n      const mi = this.getModel().getModelItem(this.nodeset);\n      if (mi) {\n        this.modelItem = mi;\n      }\n\n      const repeated = this.closest('fx-repeatitem');\n      let existed;\n      if (repeated) {\n        const { index } = this.closest('fx-repeatitem');\n        if (Array.isArray(this.nodeset)) {\n          existed = this.getModel().getModelItem(this.nodeset[index - 1]);\n        } else {\n          existed = this.getModel().getModelItem(this.nodeset);\n        }\n      } else {\n        existed = this.getModel().getModelItem(this.nodeset);\n      }\n\n      if (!existed) {\n        return FxModel.lazyCreateModelItem(this.getModel(), this.ref, this.nodeset);\n      }\n      return existed;\n    }\n\n    /**\n     * Returns the effective value for the element.\n     * a: look for 'value' attribute and if present evaluate it and return the resulting value\n     * b: look for textContent and return the value if present\n     * c: return null\n     */\n    getValue() {\n      if (this.hasAttribute('value')) {\n        const valAttr = this.getAttribute('value');\n        try {\n          const inscopeContext = getInScopeContext(this, valAttr);\n          return evaluateXPathToString(valAttr, inscopeContext, this.getOwnerForm());\n        } catch (error) {\n          console.error(error);\n          this.dispatch('error', { message: error });\n        }\n      }\n      if (this.textContent) {\n        return this.textContent;\n      }\n      return null;\n    }\n\n    getInScopeContext() {\n      return getInScopeContext(this, this.ref);\n    }\n\n    dispatch(eventName, detail) {\n      const event = new CustomEvent(eventName, {\n        composed: true,\n        bubbles: true,\n        detail,\n      });\n      console.log('firing', event);\n      this.dispatchEvent(event);\n    }\n  };\n","import { DependencyNotifyingDomFacade } from './DependencyNotifyingDomFacade.js';\nimport { foreElementMixin } from './ForeElementMixin.js';\nimport { ModelItem } from './modelitem.js';\nimport {\n  evaluateXPathToBoolean,\n  evaluateXPathToNodes,\n  evaluateXPathToString,\n} from './xpath-evaluation.js';\nimport { XPathUtil } from './xpath-util.js';\n\n/**\n * FxBind declaratively attaches constraints to nodes in the data (instances).\n *\n * It's major task is to create ModelItem Objects for each Node in the data their ref is pointing to.\n *\n * References and constraint attributes use XPath statements to point to the nodes they are attributing.\n *\n * Note: why is fx-bind not extending BoundElement? Though fx-bind has a 'ref' attr it is not bound in the sense of\n * getting updates about changes of the bound nodes. Instead it  acts as a factory for modelItems that are used by\n * BoundElements to track their state.\n */\n// export class FxBind extends HTMLElement {\nexport class FxBind extends foreElementMixin(HTMLElement) {\n  static READONLY_DEFAULT = false;\n\n  static REQUIRED_DEFAULT = false;\n\n  static RELEVANT_DEFAULT = true;\n\n  static CONSTRAINT_DEFAULT = true;\n\n  static TYPE_DEFAULT = 'xs:string';\n\n  /*\n    static get styles() {\n        return css`\n            :host {\n                display: none;\n            }\n        `;\n    }\n*/\n\n  /*\n    static get properties() {\n        return {\n            ...super.properties,\n\n            /!**\n             * allows to calculate a value. This value will become readonly.\n             *!/\n            calculate: {\n                type: String\n            },\n            contextNode:{\n                type:Object\n            },\n            /!**\n             * arbitrary XPath resolving to xs:boolean - defaults to 'true()'\n             *!/\n            constraint: {\n                type: String\n            },\n            /!**\n             * id of this bind\n             *!/\n            id:{\n                type:String\n            },\n            /!**\n             * the nodeset the bind is referring to by it's binding expression (ref attribute)\n             *!/\n            nodeset: {\n                type: Array\n            },\n            /!**\n             * the owning model of this bind\n             *!/\n            model:{\n                type:Object\n            },\n            /!**\n             * XPath statement resolving to xs:boolean to switch between readonly and readwrite mode - defaults to 'false()'\n             *!/\n            readonly: {\n                type: String\n            },\n            /!**\n             * the XPath binding expression of this bind\n             *!/\n            ref: {\n                type: String\n            },\n            /!**\n             * XPath statement resolving to xs:boolean to switch between relevant and non-relevant mode - defaults to 'true()'\n             *!/\n            relevant: {\n                type: String\n            },\n            /!**\n             * XPath statement resolving to xs:boolean to switch between required and optional - defaults to 'false'.\n             *!/\n            required: {\n                type: String\n            },\n            /!**\n             * XPath statement\n             *!/\n            type: {\n                type: String\n            }\n        };\n    }\n*/\n\n  constructor() {\n    super();\n    // this.id='';\n    // this.ref = '';\n    // this.readonly = 'false()';\n    // this.required = 'false()';\n    // this.relevant = 'true()';\n    // this.constraint = 'true()';\n    // this.type = 'xs:string';\n    // this.calculate = '';\n    this.nodeset = [];\n    this.model = {};\n    this.contextNode = {};\n    this.inited = false;\n  }\n\n  connectedCallback() {\n    // console.log('connectedCallback ', this);\n    // this.id = this.hasAttribute('id')?this.getAttribute('id'):;\n    this.ref = this.getAttribute('ref');\n    this.readonly = this.getAttribute('readonly');\n    this.required = this.getAttribute('required');\n    this.relevant = this.getAttribute('relevant');\n    this.type = this.hasAttribute('type') ? this.getAttribute('type') : FxBind.TYPE_DEFAULT;\n    this.calculate = this.getAttribute('calculate');\n  }\n\n  /**\n   * initializes the bind element by evaluating the binding expression.\n   *\n   * For each node referred to by the binding expr a ModelItem object is created.\n   *\n   * @param model\n   */\n  init(model) {\n    this.model = model;\n    console.log('init binding ', this);\n    this.instanceId = this._getInstanceId();\n    this.bindType = this.getModel().getInstance(this.instanceId).type;\n    // console.log('binding type ', this.bindType);\n\n    if (this.bindType === 'xml') {\n      this._evalInContext();\n      this._buildBindGraph();\n      this._createModelItems();\n    }\n\n    // ### process child bindings\n    this._processChildren(model);\n  }\n\n  /*\n    //todo: certainly not ideal to rely on duplicating instance id on instance document - better way later ;)\n    static getPath(node){\n        let path = fx.evaluateXPath('path()',node);\n        const instanceId = node.ownerDocument.firstElementChild.getAttribute('id');\n        if(instanceId !== 'default'){\n            return '#' + instanceId + FxBind.shortenPath(path);\n        }else {\n            return FxBind.shortenPath(path);\n        }\n\n    }\n*/\n\n  _buildBindGraph() {\n    if (this.bindType === 'xml') {\n      this.nodeset.forEach(node => {\n        const path = XPathUtil.getPath(node);\n\n        if (this.calculate) {\n          this.model.mainGraph.addNode(`${path}:calculate`, node);\n          // Calculated values are a dependency of the model item.\n          // Make `model1` depend on `model1:calculate`\n          this.model.mainGraph.addNode(path, node);\n          this.model.mainGraph.addDependency(path, `${path}:calculate`);\n        }\n\n        const calculateRefs = this._getReferencesForProperty(this.calculate, node);\n        if (calculateRefs.length !== 0) {\n          this._addDependencies(calculateRefs, node, path, 'calculate');\n        }\n\n        const readonlyRefs = this._getReferencesForProperty(this.readonly, node);\n        if (readonlyRefs.length !== 0) {\n          this._addDependencies(readonlyRefs, node, path, 'readonly');\n        } else if (this.readonly) {\n          this.model.mainGraph.addNode(`${path}:readonly`, node);\n        }\n\n        // const requiredRefs = this.requiredReferences;\n        const requiredRefs = this._getReferencesForProperty(this.required, node);\n        if (requiredRefs.length !== 0) {\n          this._addDependencies(requiredRefs, node, path, 'required');\n        } else if (this.required) {\n          this.model.mainGraph.addNode(`${path}:required`, node);\n        }\n\n        const relevantRefs = this._getReferencesForProperty(this.relevant, node);\n        if (relevantRefs.length !== 0) {\n          this._addDependencies(relevantRefs, node, path, 'relevant');\n        } else if (this.relevant) {\n          this.model.mainGraph.addNode(`${path}:relevant`, node);\n        }\n\n        const constraintRefs = this._getReferencesForProperty(this.constraint, node);\n        if (constraintRefs.length !== 0) {\n          this._addDependencies(constraintRefs, node, path, 'constraint');\n        } else if (this.constraint) {\n          this.model.mainGraph.addNode(`${path}:constraint`, node);\n        }\n      });\n    }\n  }\n\n  _addNode(path, node) {\n    if (!this.model.mainGraph.hasNode(path)) {\n      this.model.mainGraph.addNode(path, { node });\n    }\n  }\n\n  /**\n   * Add the dependencies of this bind\n   *\n   * @param  {Node[]}  refs The nodes that are referenced by this bind. these need to be resolved before\n   * this bind can be resolved.\n   * @param  {Node}    node The start of the reference\n   * @param  {string}  path The path to the start of the reference\n   * @param  {string}  property The property with this dependency\n   */\n  _addDependencies(refs, node, path, property) {\n    const nodeHash = `${path}:${property}`;\n    if (refs.length !== 0) {\n      if (!this.model.mainGraph.hasNode(nodeHash)) {\n        this.model.mainGraph.addNode(nodeHash, node);\n      }\n      refs.forEach(ref => {\n        const otherPath = XPathUtil.getPath(ref);\n\n        if (!this.model.mainGraph.hasNode(otherPath)) {\n          this.model.mainGraph.addNode(otherPath, ref);\n        }\n        this.model.mainGraph.addDependency(nodeHash, otherPath);\n      });\n    } else {\n      this.model.mainGraph.addNode(nodeHash, node);\n    }\n  }\n\n  _processChildren(model) {\n    const childbinds = this.querySelectorAll(':scope > fx-bind');\n    Array.from(childbinds).forEach(bind => {\n      // console.log('init child bind ', bind);\n      bind.init(model);\n    });\n  }\n\n  /*\n    render() {\n        return html`\n             <slot></slot>\n        `;\n    }\n*/\n\n  getAlert() {\n    if (this.hasAttribute('alert')) {\n      return this.getAttribute('alert');\n    }\n    const alertChild = this.querySelector('fx-alert');\n    if (alertChild) {\n      return alertChild.innerHTML;\n    }\n    return null;\n  }\n\n  /*\n        firstUpdated(_changedProperties) {\n            super.firstUpdated(_changedProperties);\n        }\n    */\n\n  /*\n  namespaceResolver(prefix) {\n    // TODO: Do proper namespace resolving. Look at the ancestry / namespacesInScope of the declaration\n\n    /!**\n     * for (let ancestor = this; ancestor; ancestor = ancestor.parentNode) {\n     * \tif (ancestor.getAttribute(`xmlns:${prefix}`)) {\n     *   // Return value\n     *  }\n     * }\n     *!/\n\n    // console.log('namespaceResolver  prefix', prefix);\n    const ns = {\n      xhtml: 'http://www.w3.org/1999/xhtml',\n      // ''    : Fore.XFORMS_NAMESPACE_URI\n    };\n    return ns[prefix] || null;\n  }\n*/\n\n  /**\n   * overwrites\n   */\n  _evalInContext() {\n    const inscopeContext = this.getInScopeContext();\n\n    // reset nodeset\n    this.nodeset = [];\n\n    if (this.ref === '' || this.ref === null) {\n      this.nodeset = inscopeContext;\n    } else if (Array.isArray(inscopeContext)) {\n      inscopeContext.forEach(n => {\n        if (XPathUtil.isSelfReference(this.ref)) {\n          this.nodeset = inscopeContext;\n        } else {\n          // eslint-disable-next-line no-lonely-if\n          if (this.ref) {\n            const localResult = evaluateXPathToNodes(this.ref, n, this.getOwnerForm());\n            localResult.forEach(item => {\n              this.nodeset.push(item);\n            });\n            /*\n                                                const localResult = fx.evaluateXPathToFirstNode(this.ref, n, null, {namespaceResolver:  this.namespaceResolver});\n                                                this.nodeset.push(localResult);\n                        */\n          }\n          // console.log('local result: ', localResult);\n          // this.nodeset.push(localResult);\n        }\n      });\n    } else {\n      const inst = this.getModel().getInstance(this.instanceId);\n      if (inst.type === 'xml') {\n        this.nodeset = evaluateXPathToNodes(this.ref, inscopeContext, this.getOwnerForm());\n      } else {\n        this.nodeset = this.ref;\n      }\n    }\n  }\n\n  _createModelItems() {\n    // console.log('#### ', thi+s.nodeset);\n\n    /*\n                if(XPathUtil.isSelfReference(this.ref)){\n                    return;\n                }\n        */\n    if (Array.isArray(this.nodeset)) {\n      // todo - iterate and create\n      // console.log('################################################ ', this.nodeset);\n      // Array.from(this.nodeset).forEach((n, index) => {\n      Array.from(this.nodeset).forEach(n => {\n        // console.log('node ',n);\n        // this._createModelItem(n, index);\n        this._createModelItem(n);\n      });\n    } else {\n      this._createModelItem(this.nodeset);\n    }\n  }\n\n  static lazyCreateModelitems(model, ref, nodeset) {\n    if (Array.isArray(nodeset)) {\n      Array.from(nodeset).forEach(n => {\n        FxBind.lazyCreateModelItem(model, ref, n);\n      });\n    } else {\n      FxBind.lazyCreateModelItem(model, ref, nodeset);\n    }\n  }\n\n  /*\n    static lazyCreateModelItem(model,ref,node){\n        console.log('lazyCreateModelItem ', node);\n\n        let mItem = {};\n        let targetNode = {};\n        if(node === null) return null;\n        if(node.nodeType === node.TEXT_NODE){\n            // const parent = node.parentNode;\n            // console.log('PARENT ', parent);\n            targetNode = node.parentNode;\n        }else {\n            targetNode = node;\n        }\n\n        // const path = fx.evaluateXPath('path()',node);\n        const path = FxBind.getPath(node);\n\n        // const path = Fore.evaluateXPath ('path()', node, this, Fore.namespaceResolver) ;\n\n        // ### intializing ModelItem with default values (as there is no <fx-bind> matching for given ref)\n        const mi = new ModelItem(path,\n            ref,\n            FxBind.READONLY_DEFAULT,\n            FxBind.RELEVANT_DEFAULT,\n            FxBind.REQUIRED_DEFAULT,\n            FxBind.CONSTRAINT_DEFAULT,\n            FxBind.TYPE_DEFAULT,\n            targetNode,\n            this);\n\n\n        // console.log('new ModelItem is instanceof ModelItem ', mi instanceof ModelItem);\n        model.registerModelItem(mi);\n        return mi;\n    }\n*/\n\n  /**\n   * creates a ModelItem for given instance node.\n   *\n   * Please note that for textnode no ModelItem is created but instead the one of its parent is used which either\n   * must exist and be initialized already when we hit the textnode.\n   * @param node\n   * @private\n   */\n  // _createModelItem(node, index) {\n  _createModelItem(node) {\n    // console.log('_createModelItem node', node, index);\n\n    /*\n                this.calculateReferences = this._getReferencesForProperty(this.calculate,node);\n                this.readOnlyReferences = this._getReferencesForProperty(this.readonly,node);\n                this.requiredReferences = this._getReferencesForProperty(this.required,node);\n                this.relevantReferences = this._getReferencesForProperty(this.relevant,node);\n                this.constraintReferences = this._getReferencesForProperty(this.constraint,node);\n        */\n\n    /*\n        if bind is the dot expression we use the modelitem of the parent\n         */\n    if (XPathUtil.isSelfReference(this.ref)) {\n      const parentBoundElement = this.parentElement.closest('fx-bind[ref]');\n      console.log('parent bound element ', parentBoundElement);\n\n      if (parentBoundElement) {\n        // todo: Could be fancier by combining them\n        parentBoundElement.required = this.required; // overwrite parent property!\n      } else {\n        console.error('no parent bound element');\n      }\n\n      return;\n    }\n\n    // let value = null;\n    // const mItem = {};\n    /*\n    let targetNode = {};\n    if (node.nodeType === node.TEXT_NODE) {\n      // const parent = node.parentNode;\n      // console.log('PARENT ', parent);\n      targetNode = node.parentNode;\n    } else {\n      targetNode = node;\n    }\n*/\n    const targetNode = node;\n\n    // const path = fx.evaluateXPath('path()',node);\n    // const path = this.getPath(node);\n    const path = XPathUtil.getPath(node);\n    // const shortPath = this.shortenPath(path);\n\n    // ### constructiong default modelitem - will get evaluated during reaalculate()\n    // ### constructiong default modelitem - will get evaluated during reaalculate()\n    // ### constructiong default modelitem - will get evaluated during reaalculate()\n    // const newItem = new ModelItem(shortPath,\n    const newItem = new ModelItem(\n      path,\n      this.getBindingExpr(),\n      FxBind.READONLY_DEFAULT,\n      FxBind.RELEVANT_DEFAULT,\n      FxBind.REQUIRED_DEFAULT,\n      FxBind.CONSTRAINT_DEFAULT,\n      this.type,\n      targetNode,\n      this,\n    );\n\n    this.getModel().registerModelItem(newItem);\n  }\n\n  /**\n   * Get the nodes that are referred by the given XPath expression\n   *\n   * @param  {string}  propertyExpr  The XPath to get the referenced nodes from\n   *\n   * @return {Node[]}  The nodes that are referenced by the XPath\n   */\n  _getReferencesForProperty(propertyExpr) {\n    if (propertyExpr) {\n      const touchedNodes = new Set();\n      const domFacade = new DependencyNotifyingDomFacade(otherNode => touchedNodes.add(otherNode));\n      this.nodeset.forEach(node => {\n        evaluateXPathToString(propertyExpr, node, this.getOwnerForm(), domFacade);\n      });\n\n      return Array.from(touchedNodes.values());\n    }\n    return [];\n  }\n\n  _initBooleanModelItemProperty(property, node) {\n    // evaluate expression to boolean\n    const propertyExpr = this[property];\n    // console.log('####### ', propertyExpr);\n    const result = evaluateXPathToBoolean(propertyExpr, node, this);\n    return result;\n  }\n\n  static shortenPath(path) {\n    const steps = path.split('/');\n    let result = '';\n    for (let i = 2; i < steps.length; i += 1) {\n      const step = steps[i];\n      if (step.indexOf('{}') !== -1) {\n        const q = step.split('{}');\n        result += `/${q[1]}`;\n      } else {\n        result += `/${step}`;\n      }\n    }\n    return result;\n  }\n\n  // todo: more elaborated implementation ;)\n  _getInstanceId() {\n    const bindExpr = this.getBindingExpr();\n    // console.log('_getInstanceId bindExpr ', bindExpr);\n    if (bindExpr.startsWith('instance(')) {\n      this.instanceId = XPathUtil.getInstanceId(bindExpr);\n      return this.instanceId;\n    }\n    if (this.instanceId) {\n      return this.instanceId;\n    }\n    return 'default';\n  }\n}\ncustomElements.define('fx-bind', FxBind);\n","import { Fore } from './fore.js';\nimport './fx-instance.js';\nimport './fx-model.js';\nimport '@jinntec/jinn-toast';\nimport { evaluateXPathToNodes, evaluateXPathToString } from './xpath-evaluation.js';\nimport getInScopeContext from './getInScopeContext.js';\n\n/**\n * Main class for Fore.Outermost container element for each Fore application.\n *\n *\n *\n * Root element for Fore. Kicks off initialization and displays messages.\n *\n * fx-fore is the outermost container for each form. A form can have exactly one model\n * with arbitrary number of instances.\n *\n * Main responsiblities are initialization of model, update of UI (refresh) and global messaging\n *\n * @ts-check\n */\nexport class FxFore extends HTMLElement {\n  static get properties() {\n    return {\n      model: {\n        type: Object,\n      },\n      ready: {\n        type: Boolean,\n      },\n    };\n  }\n\n  constructor() {\n    super();\n    this.model = {};\n    this.addEventListener('model-construct-done', this._handleModelConstructDone);\n    this.addEventListener('message', this._displayMessage);\n    this.addEventListener('error', this._displayError);\n    window.addEventListener('compute-exception', e => {\n      console.error('circular dependency: ', e);\n    });\n\n    this.ready = false;\n\n    this.storedTemplateExpressionByNode = new Map();\n\n    const style = `\n            :host {\n                display: block;\n                height:auto;\n                padding:var(--model-element-padding);\n                font-family:Roboto, sans-serif;\n                color:var(--paper-grey-900);\n            }\n            :host ::slotted(fx-model){\n                display:none;\n            }\n            #modalMessage .dialogActions{\n                text-align:center;\n            }\n            .overlay {\n              position: fixed;\n              top: 0;\n              bottom: 0;\n              left: 0;\n              right: 0;\n              background: rgba(0, 0, 0, 0.7);\n              transition: all 500ms;\n              visibility: hidden;\n              opacity: 0;\n              z-index:10;\n            }\n            .overlay.show {\n              visibility: visible;\n              opacity: 1;\n            }\n\n            .popup {\n              margin: 70px auto;\n              background: #fff;\n              border-radius: 5px;\n              width: 30%;\n              position: relative;\n              transition: all 5s ease-in-out;\n                            padding: 20px;\n\n            }\n            .popup h2 {\n              margin-top: 0;\n              width:100%;\n              background:#eee;\n              position:absolute;\n              top:0;\n              right:0;\n              left:0;\n              height:40px;\n             border-radius: 5px;\n\n            }\n            .popup .close {\n                position: absolute;\n                top: 3px;\n                right: 10px;\n                transition: all 200ms;\n                font-size: 30px;\n                font-weight: bold;\n                text-decoration: none;\n                color: #333;\n            }\n            .popup .close:focus{\n                outline:none;\n            }\n\n            .popup .close:hover {\n                color: #06D85F;\n            }\n            #messageContent{\n                margin-top:40px;\n            }\n        `;\n\n    const html = `\n           <jinn-toast id=\"message\" gravity=\"bottom\" position=\"left\"></jinn-toast>\n           <jinn-toast id=\"error\" text=\"error\" duration=\"-1\" data-class=\"error\" close=\"true\" position=\"left\" gravity=\"bottom\"></jinn-toast>\n           <slot></slot>\n           <div id=\"modalMessage\" class=\"overlay\">\n                <div class=\"popup\">\n                   <h2></h2>\n                    <a class=\"close\" href=\"#\"  onclick=\"event.target.parentNode.parentNode.classList.remove('show')\" autofocus>&times;</a>\n                    <div id=\"messageContent\"></div>\n                </div>\n           </div>\n        `;\n\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.innerHTML = `\n            <style>\n                ${style}\n            </style>\n            ${html}\n        `;\n  }\n\n  connectedCallback() {\n    const slot = this.shadowRoot.querySelector('slot');\n    slot.addEventListener('slotchange', event => {\n      const children = event.target.assignedElements();\n      let modelElement = children.find(\n        modelElem => modelElem.nodeName.toUpperCase() === 'FX-MODEL',\n      );\n      if (!modelElement) {\n        const generatedModel = document.createElement('FX-model');\n        this.appendChild(generatedModel);\n        modelElement = generatedModel;\n      }\n      if (!modelElement.inited) {\n        console.log('########## FORE: kick off processing... ##########');\n        modelElement.modelConstruct();\n      }\n      this.model = modelElement;\n    });\n  }\n\n  evaluateToNodes(xpath, context) {\n    return evaluateXPathToNodes(xpath, context, this);\n  }\n\n  disconnectedCallback() {}\n\n  /**\n   * refreshes the whole UI by visiting each bound element (having a 'ref' attribute) and applying the state of\n   * the bound modelItem to the bound element.\n   *\n   *\n   * AVT:\n   *\n   */\n  async refresh() {\n    // refresh () {\n    console.group('### refresh');\n    // await this.updateComplete;\n\n    Fore.refreshChildren(this);\n    // this.dispatchEvent(new CustomEvent('refresh-done', {detail:'foo'}));\n\n    // ### refresh template expressions\n    this._updateTemplateExpressions();\n\n    console.groupEnd();\n    console.log('### <<<<< dispatching refresh-done - end of UI update cycle >>>>>');\n    this.dispatchEvent(new CustomEvent('refresh-done'));\n  }\n\n  /**\n   * entry point for processing of template expression enclosed in '{}' brackets.\n   *\n   * Expressions are found with an XPath search. For each node an entry is added to the storedTemplateExpressionByNode map.\n   *\n   *\n   * @private\n   */\n  _updateTemplateExpressions() {\n    // Note the fact we're going over HTML here: therefore the `html` prefix.\n    const search =\n      \"(descendant-or-self::*/(text(), @*))[matches(.,'\\\\{.*\\\\}')] except descendant-or-self::xhtml:fx-model/descendant-or-self::node()/(., @*)\";\n\n    const tmplExpressions = evaluateXPathToNodes(search, this, this);\n    console.log('template expressions found ', tmplExpressions);\n\n    /*\n                storing expressions and their nodes for re-evaluation\n             */\n    Array.from(tmplExpressions).forEach(node => {\n      if (this.storedTemplateExpressionByNode.has(node)) {\n        // If the node is already known, do not process it twice\n        return;\n      }\n      const expr = this._getTemplateExpression(node);\n\n      this.storedTemplateExpressionByNode.set(node, expr);\n    });\n\n    // TODO: Should we clean up nodes that existed but are now gone?\n    for (const node of this.storedTemplateExpressionByNode.keys()) {\n      this._processTemplateExpression({\n        node,\n        expr: this.storedTemplateExpressionByNode.get(node),\n      });\n    }\n\n    console.log('stored template expressions ', this.storedTemplateExpressionByNode);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  _processTemplateExpression(exprObj) {\n    // console.log('processing template expression ', exprObj);\n\n    const { expr } = exprObj;\n    const { node } = exprObj;\n    // console.log('expr ', expr);\n    this.evaluateTemplateExpression(expr, node, this);\n  }\n\n  /**\n   * evaluate a template expression (some expression in {} brackets) on a node (either text- or attribute node.\n   * @param expr the XPath to evaluate\n   * @param node the node which will get updated with evaluation result\n   * @param form the form element\n   */\n  evaluateTemplateExpression(expr, node) {\n    const matches = expr.match(/{[^}]*}/g);\n    const namespaceContextNode =\n      node.nodeType === node.TEXT_NODE ? node.parentNode : node.ownerElement;\n    if (matches) {\n      matches.forEach(match => {\n        // console.log('match ', match);\n        const naked = match.substring(1, match.length - 1);\n        const inscope = getInScopeContext(node, naked);\n        if (!inscope) {\n          const errNode =\n            node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ATTRIBUTE_NODE\n              ? node.parentNode\n              : node;\n          console.warn('no inscope context for ', errNode);\n          return;\n        }\n        // Templates are special: they use the namespace configuration from the place where they are\n        // being defined\n\n        try {\n          const result = evaluateXPathToString(naked, inscope, this, null, namespaceContextNode);\n\n          // console.log('result of eval ', result);\n          const replaced = expr.replaceAll(match, result);\n          console.log('result of replacing ', replaced);\n\n          if (node.nodeType === Node.ATTRIBUTE_NODE) {\n            const parent = node.ownerElement;\n\n            // parent.setAttribute(name, replaced);\n            parent.setAttribute(node.nodeName, replaced);\n          } else if (node.nodeType === Node.TEXT_NODE) {\n            node.textContent = replaced;\n          }\n        } catch (error) {\n          this.dispatchEvent(new CustomEvent('error', { detail: error }));\n        }\n      });\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  _getTemplateExpression(node) {\n    if (node.nodeType === Node.ATTRIBUTE_NODE) {\n      return node.value;\n    }\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node.textContent;\n    }\n    return null;\n  }\n\n  _refreshChildren() {\n    const uiElements = this.querySelectorAll('*');\n\n    uiElements.forEach(element => {\n      if (Fore.isUiElement(element.nodeName) && typeof element.refresh === 'function') {\n        element.refresh();\n      }\n    });\n  }\n\n  _handleModelConstructDone() {\n    this._initUI();\n  }\n\n  async _lazyCreateInstance() {\n    const model = this.querySelector('fx-model');\n    if (model.instances.length === 0) {\n      console.log('### lazy creation of instance');\n      const generatedInstance = document.createElement('fx-instance');\n      model.appendChild(generatedInstance);\n\n      const generated = document.implementation.createDocument(null, 'data', null);\n      // const newData = this._generateInstance(this, generated.firstElementChild);\n      this._generateInstance(this, generated.firstElementChild);\n      generatedInstance.instanceData = generated;\n      model.instances.push(generatedInstance);\n      console.log('generatedInstance ', this.getModel().getDefaultInstanceData());\n    }\n  }\n\n  /**\n   * @param {Element} start\n   * @param {Element} parent\n   */\n  _generateInstance(start, parent) {\n    if (start.hasAttribute('ref') && !Fore.isActionElement(start.nodeName)) {\n      const ref = start.getAttribute('ref');\n\n      if (ref.includes('/')) {\n        console.log('complex path to create ', ref);\n        const steps = ref.split('/');\n        steps.forEach(step => {\n          console.log('step ', step);\n\n          // const generated = document.createElement(ref);\n          parent = this._generateNode(parent, step, start);\n        });\n      } else {\n        parent = this._generateNode(parent, ref, start);\n      }\n    }\n\n    if (start.hasChildNodes()) {\n      const list = start.children;\n      for (let i = 0; i < list.length; i += 1) {\n        this._generateInstance(list[i], parent);\n      }\n    }\n    return parent;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  _generateNode(parent, step, start) {\n    const generated = parent.ownerDocument.createElement(step);\n    if (start.children.length === 0) {\n      generated.textContent = start.textContent;\n    }\n    parent.appendChild(generated);\n    parent = generated;\n    return parent;\n  }\n\n  /*\n        _createStep(){\n\n        }\n      */\n\n  /*\n        _generateInstance(start, parent) {\n          if (start.hasAttribute('ref')) {\n            const ref = start.getAttribute('ref');\n\n            if(ref.includes('/')){\n              console.log('complex path to create ', ref);\n              const steps = ref.split('/');\n              steps.forEach(step => {\n                console.log('step ', step);\n\n\n              });\n            }\n\n            // const generated = document.createElement(ref);\n            const generated = parent.ownerDocument.createElement(ref);\n            if (start.children.length === 0) {\n              generated.textContent = start.textContent;\n            }\n            parent.appendChild(generated);\n            parent = generated;\n          }\n\n          if (start.hasChildNodes()) {\n            const list = start.children;\n            for (let i = 0; i < list.length; i += 1) {\n              this._generateInstance(list[i], parent);\n            }\n          }\n          return parent;\n        }\n      */\n\n  async _initUI() {\n    console.log('### _initUI()');\n\n    await this._lazyCreateInstance();\n    await this.refresh();\n    this.ready = true;\n    console.log('### <<<<< dispatching ready >>>>>');\n    console.log('########## modelItems: ', this.getModel().modelItems);\n    console.log('########## FORE: form fully initialized... ##########');\n    this.dispatchEvent(new CustomEvent('ready', {}));\n  }\n\n  /**\n   *\n   * @returns {FxModel}\n   */\n  getModel() {\n    return this.querySelector('fx-model');\n  }\n\n  _displayMessage(e) {\n    const { level } = e.detail;\n    const msg = e.detail.message;\n    this._showMessage(level, msg);\n  }\n\n  _displayError(e) {\n    // const { error } = e.detail;\n    const msg = e.detail.message;\n    // this._showMessage('modal', msg);\n    const toast = this.shadowRoot.querySelector('#error');\n    toast.showToast(msg);\n  }\n\n  _showMessage(level, msg) {\n    if (level === 'modal') {\n      // this.$.messageContent.innerText = msg;\n      // this.$.modalMessage.open();\n\n      this.shadowRoot.getElementById('messageContent').innerText = msg;\n      // this.shadowRoot.getElementById('modalMessage').open();\n      this.shadowRoot.getElementById('modalMessage').classList.add('show');\n    } else if (level === 'modeless') {\n      // const notification = this.$.modeless;\n      this.shadowRoot.querySelector('#message').showToast(msg);\n    } else {\n      const toast = this.shadowRoot.querySelector('#message');\n      toast.showToast(msg);\n    }\n  }\n}\n\ncustomElements.define('fx-fore', FxFore);\n","import { Fore } from './fore.js';\nimport { foreElementMixin } from './ForeElementMixin.js';\nimport { evaluateXPathToString, evaluateXPath } from './xpath-evaluation.js';\nimport getInScopeContext from './getInScopeContext.js';\n\n/**\n * todo: validate='false'\n */\nexport class FxSubmission extends foreElementMixin(HTMLElement) {\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n  }\n\n  connectedCallback() {\n    // this.style.display = 'none';\n    this.methods = ['get', 'put', 'post', 'delete', 'head', 'urlencoded-post'];\n\n    this.model = this.parentNode;\n\n    // ### initialize properties with defaults\n    // if (!this.hasAttribute('id')) throw new Error('id is required');\n    if (!this.hasAttribute('id')) console.warn('id is required');\n    this.id = this.getAttribute('id');\n\n    /** if present should be a existing instance id */\n    this.instance = this.hasAttribute('instance') ? this.getAttribute('instance') : null;\n\n    /** http method */\n    this.method = this.hasAttribute('method') ? this.getAttribute('method') : 'get';\n\n    /** relevance processing - one of 'remove, keep or empty' */\n    this.nonrelevant = this.hasAttribute('nonrelevant')\n      ? this.getAttribute('nonrelevant')\n      : 'remove';\n\n    /** replace might be 'all', 'instance' or 'none' */\n    this.replace = this.hasAttribute('replace') ? this.getAttribute('replace') : 'all';\n\n    this.serialization = this.hasAttribute('serialization')\n      ? this.getAttribute('serialization')\n      : 'xml';\n\n    // if (!this.hasAttribute('url')) throw new Error(`url is required for submission: ${this.id}`);\n    if (!this.hasAttribute('url')) console.warn(`url is required for submission: ${this.id}`);\n    this.url = this.getAttribute('url');\n\n    this.targetref = this.hasAttribute('targetref') ? this.getAttribute('targetref') : null;\n\n    this.mediatype = this.hasAttribute('mediatype')\n      ? this.getAttribute('mediatype')\n      : 'application/xml';\n\n    this.validate = this.getAttribute('validate') ? this.getAttribute('validate') : 'true';\n    this.shadowRoot.innerHTML = this.renderHTML();\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  renderHTML() {\n    return `\n      <slot></slot>\n    `;\n  }\n\n  async submit() {\n    await this.dispatch('submit', { submission: this });\n    this._submit();\n  }\n\n  async _submit() {\n    console.log('submitting....');\n    this.evalInContext();\n    const model = this.getModel();\n\n    model.recalculate();\n\n    if (this.validate) {\n      const valid = model.revalidate();\n      if (!valid) {\n        console.log('validation failed. Bubmission stopped');\n        return;\n      }\n    }\n    console.log('model updated....');\n    await this._serializeAndSend();\n  }\n\n  /**\n   * resolves template expressions for a single attribute\n   * @param expr the attribute value to evaluate\n   * @param node the attribute node used for scoped resolution\n   * @returns {*}\n   * @private\n   */\n  _evaluateAttributeTemplateExpression(expr, node) {\n    const matches = expr.match(/{[^}]*}/g);\n    if (matches) {\n      matches.forEach(match => {\n        console.log('match ', match);\n        const naked = match.substring(1, match.length - 1);\n        const inscope = getInScopeContext(node, naked);\n        const result = evaluateXPathToString(naked, inscope, this.getOwnerForm());\n        const replaced = expr.replaceAll(match, result);\n        console.log('replacing ', expr, ' with ', replaced);\n        expr = replaced;\n      });\n    }\n    return expr;\n  }\n\n  /**\n   * sends the data after evaluating\n   *\n   * todo: can send only XML at the moment\n   * @private\n   */\n  async _serializeAndSend() {\n    const resolvedUrl = this._evaluateAttributeTemplateExpression(this.url, this);\n\n    const instance = this.getInstance();\n    if (instance.type !== 'xml') {\n      console.error('JSON serialization is not supported yet');\n      return;\n    }\n\n    // let serialized = serializer.serializeToString(this.nodeset);\n    let serialized;\n    if (this.serialization === 'none') {\n      serialized = undefined;\n    } else {\n      const relevant = this.selectRelevant();\n      serialized = this._serialize(instance.type, relevant);\n    }\n\n    // let serialized = serializer.serializeToString(relevant);\n    if (this.method.toLowerCase() === 'get') {\n      serialized = undefined;\n    }\n    // console.log('data being send', serialized);\n    // console.log('submitting data',serialized);\n\n    if (resolvedUrl === '#echo') {\n      let doc;\n      if (serialized) {\n        doc = new DOMParser().parseFromString(serialized, 'application/xml');\n      } else {\n        doc = undefined;\n      }\n      // const doc = new DOMParser().parseFromString(serialized, 'application/xml');\n      // const newDoc = doc.replaceChild(relevant, doc.firstElementChild);\n      this._handleResponse(doc);\n      this.dispatch('submit-done', {});\n      return;\n    }\n    // ### setting headers\n    const headers = this._getHeaders();\n    console.log('headers', headers);\n\n    // ### map urlencoded-post to post for fetch\n    if (this.method === 'urlencoded-post') {\n      this.method = 'post';\n    }\n\n    if (!this.methods.includes(this.method.toLowerCase())) {\n      this.dispatch('error', { message: `Unknown method ${this.method}` });\n      return;\n    }\n    const response = await fetch(resolvedUrl, {\n      method: this.method,\n      mode: 'cors',\n      credentials: 'include',\n      headers,\n      body: serialized,\n    });\n\n    const contentType = response.headers.get('content-type').toLowerCase();\n\n    if (contentType.startsWith('text/plain') || contentType.startsWith('text/html')) {\n      const text = await response.text();\n      this._handleResponse(text);\n    } else if (contentType.startsWith('application/json')) {\n      const json = await response.json();\n      this._handleResponse(json);\n    } else if (contentType.startsWith('application/xml')) {\n      const text = await response.text();\n      const xml = new DOMParser().parseFromString(text, 'application/xml');\n      this._handleResponse(xml);\n    } else {\n      const blob = await response.blob();\n      this._handleResponse(blob);\n    }\n\n    if (!response.ok || response.status > 400) {\n      this.dispatch('submit-error', { message: `Error while submitting ${this.id}` });\n      return;\n    }\n    this.dispatch('submit-done', {});\n  }\n\n  _serialize(instanceType, relevantNodes) {\n    if (this.method === 'urlencoded-post') {\n      // this.method = 'post';\n      const params = new URLSearchParams();\n      // console.log('nodes to serialize', relevantNodes);\n      Array.from(relevantNodes.children).forEach(child => {\n        params.append(child.nodeName, child.textContent);\n      });\n      return params;\n    }\n    if (instanceType === 'xml') {\n      const serializer = new XMLSerializer();\n      return serializer.serializeToString(relevantNodes);\n    }\n    /*\n            if(instanceType === 'json'){\n                console.warn('JSON serialization is not yet supported')\n            }\n    */\n    throw new Error('unknown instance type ', instanceType);\n  }\n\n  _getHeaders() {\n    const headers = new Headers();\n\n    // ### set content-type header according to type of instance\n    const instance = this.getInstance();\n    const contentType = Fore.getContentType(instance, this.method);\n    headers.append('Content-Type', contentType);\n    // ### needed to overwrite browsers' setting of 'Accept' header\n    if (headers.has('Accept')) {\n      headers.delete('Accept');\n    }\n    // headers.append('Accept', 'application/xml');\n\n    // ### add header defined by fx-header elements\n    const headerElems = this.querySelectorAll('fx-header');\n    Array.from(headerElems).forEach(header => {\n      const { name } = header;\n      const val = header.getValue();\n      headers.append(name, val);\n    });\n    return headers;\n  }\n\n  _getUrlExpr() {\n    return this.storedTemplateExpressions.find(stored => stored.node.nodeName === 'url');\n  }\n\n  _getTargetInstance() {\n    let targetInstance;\n    if (this.instance) {\n      targetInstance = this.model.getInstance(this.instance);\n    } else {\n      targetInstance = this.model.getInstance('default');\n    }\n    if (!targetInstance) {\n      throw new Error(`target instance not found: ${targetInstance}`);\n    }\n    return targetInstance;\n  }\n\n  _handleResponse(data) {\n    console.log('_handleResponse ', data);\n    if (this.replace === 'instance') {\n      const targetInstance = this._getTargetInstance();\n      if (targetInstance) {\n        if (this.targetref) {\n          const theTarget = evaluateXPath(this.targetref, targetInstance, this.getOwnerForm());\n          console.log('theTarget', theTarget);\n          const clone = data.firstElementChild;\n          const parent = theTarget.parentNode;\n          parent.replaceChild(clone, theTarget);\n          console.log('finally ', parent);\n        } else {\n          const instanceData = data;\n          targetInstance.instanceData = instanceData;\n          console.log('### replaced instance ', targetInstance.instanceData);\n        }\n\n        this.model.updateModel(); // force update\n        // this.model.formElement.refresh();\n        this.getOwnerForm().refresh();\n      } else {\n        throw new Error(`target instance not found: ${targetInstance}`);\n      }\n    }\n\n    if (this.replace === 'all') {\n      document.getElementsByTagName('html')[0].innerHTML = data;\n    }\n    if (this.replace === 'target') {\n      const target = this.getAttribute('target');\n      const targetNode = document.querySelector(target);\n      targetNode.innerHTML = data;\n    }\n    if (this.replace === 'redirect') {\n      window.location.href = data;\n    }\n\n    /*\n                const event = new CustomEvent('submit-done', {\n                    composed: true,\n                    bubbles: true,\n                    detail: {},\n                });\n                console.log('firing',event);\n                this.dispatchEvent(event);\n        */\n    // this.dispatch('submit-done', {});\n  }\n\n  /**\n   * select relevant nodes\n   *\n   * todo: support for 'empty'\n   * @returns {*}\n   */\n  selectRelevant() {\n    // ### no relevance selection - current nodeset is used 'as-is'\n    if (this.nonrelevant === 'keep') {\n      return this.nodeset;\n    }\n\n    // first check if nodeset of submission is relevant - otherwise bail out\n    const mi = this.getModel().getModelItem(this.nodeset);\n    if (mi && !mi.relevant) return null;\n\n    const doc = new DOMParser().parseFromString('<data></data>', 'application/xml');\n    const root = doc.firstElementChild;\n\n    if (this.nodeset.children.length === 0 && this._isRelevant(this.nodeset)) {\n      return this.nodeset;\n    }\n    const result = this._filterRelevant(this.nodeset, root);\n    return result;\n  }\n\n  _filterRelevant(node, result) {\n    const { childNodes } = node;\n    Array.from(childNodes).forEach(n => {\n      if (this._isRelevant(n)) {\n        const clone = n.cloneNode(false);\n        result.appendChild(clone);\n        const { attributes } = n;\n        if (attributes) {\n          Array.from(attributes).forEach(attr => {\n            if (this._isRelevant(attr)) {\n              clone.setAttribute(attr.nodeName, attr.value);\n            } else if (this.nonrelevant === 'empty') {\n              clone.setAttribute(attr.nodeName, '');\n            } else {\n              clone.removeAttribute(attr.nodeName);\n            }\n          });\n        }\n        return this._filterRelevant(n, clone);\n      }\n      return null;\n    });\n    return result;\n  }\n\n  _isRelevant(node) {\n    const mi = this.getModel().getModelItem(node);\n    if (!mi || mi.relevant) {\n      return true;\n    }\n    return false;\n  }\n\n  _handleError() {\n    this.dispatch('submit-error', {});\n    /*\n                console.log('ERRRORRRRR');\n                this.dispatchEvent(\n                    new CustomEvent('submit-error', {\n                        composed: true,\n                        bubbles: true,\n                        detail: {},\n                    }),\n                );\n        */\n  }\n}\n\ncustomElements.define('fx-submission', FxSubmission);\n","import { foreElementMixin } from './ForeElementMixin.js';\n\nexport class FxHeader extends foreElementMixin(HTMLElement) {\n  constructor() {\n    super();\n    this.style.display = 'none';\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.innerHTML = ``;\n\n    if (!this.hasAttribute('name')) {\n      throw new Error('required attribute \"name\" missing');\n    }\n    this.name = this.getAttribute('name');\n  }\n\n  connectedCallback() {\n    this.shadowRoot.innerHTML = ``;\n  }\n}\ncustomElements.define('fx-header', FxHeader);\n","import '../fx-model.js';\nimport { foreElementMixin } from '../ForeElementMixin.js';\nimport { ModelItem } from '../modelitem.js';\n\n/**\n * `AbstractControl` -\n * is a general base class for control elements.\n *\n */\nexport default class AbstractControl extends foreElementMixin(HTMLElement) {\n  constructor() {\n    super();\n    this.value = '';\n    this.display = this.style.display;\n    this.required = false;\n    this.readonly = false;\n    this.widget = null;\n    // this.attachShadow({ mode: 'open' });\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  getWidget() {\n    throw new Error('You have to implement the method getWidget!');\n  }\n\n  /**\n   * (re)apply all modelItem state properties to this control. model -> UI\n   */\n  async refresh() {\n    console.log('### AbstractControl.refresh on : ', this);\n\n    const currentVal = this.value;\n\n    // if(this.repeated) return ;\n    if (this.isNotBound()) return;\n\n    // await this.updateComplete;\n    // await this.getWidget();\n    this.evalInContext();\n\n    if (this.isBound()) {\n      // this.control = this.querySelector('#control');\n\n      if (this.nodeset === null) {\n        this.style.display = 'none';\n        return;\n      }\n\n      this.modelItem = this.getModelItem();\n\n      if (this.modelItem instanceof ModelItem) {\n        // console.log('### XfAbstractControl.refresh modelItem : ', this.modelItem);\n\n        this.value = this.modelItem.value;\n        // console.log('>>>>>>>> abstract refresh ', this.control);\n        // this.control[this.valueProp] = this.value;\n        await this.updateWidgetValue();\n        this.handleModelItemProperties();\n\n        // if(!this.closest('fx-fore').ready) return; // state change event do not fire during init phase (initial refresh)\n        if (!this.getOwnerForm().ready) return; // state change event do not fire during init phase (initial refresh)\n        if (currentVal !== this.value) {\n          // console.log('dispatching value-changed for ', this);\n          // console.log('value-changed path ', this.modelItem.path);\n          this.dispatch('value-changed', { path: this.modelItem.path });\n        }\n        // this.requestUpdate();\n      }\n    }\n    // await this.updateComplete;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async updateWidgetValue() {\n    throw new Error('You have to implement the method updateWidgetValue!');\n  }\n\n  handleModelItemProperties() {\n    console.log('form ready', this.getOwnerForm().ready);\n    this.handleRequired();\n    this.handleReadonly();\n    if (this.getOwnerForm().ready) {\n      this.handleValid();\n    }\n    this.handleRelevant();\n  }\n\n  _getForm() {\n    return this.getModel().parentNode;\n  }\n\n  _dispatchEvent(event) {\n    if (this.getOwnerForm().ready) {\n      this.dispatch(event, {});\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  handleRequired() {\n    // console.log('mip required', this.modelItem.required);\n    // const control = this.querySelector('#control');\n    this.widget = this.getWidget();\n    if (this.isRequired() !== this.modelItem.required) {\n      if (this.modelItem.required) {\n        this.widget.setAttribute('required', 'required');\n        this.classList.add('required');\n        this._dispatchEvent('required');\n      } else {\n        this.widget.removeAttribute('required');\n        this.required = false;\n        // this.removeAttribute('required');\n        this.classList.toggle('required');\n        this._dispatchEvent('optional');\n      }\n    }\n  }\n\n  handleReadonly() {\n    // console.log('mip readonly', this.modelItem.isReadonly);\n    if (this.isReadonly() !== this.modelItem.readonly) {\n      if (this.modelItem.readonly) {\n        this.widget.setAttribute('readonly', 'readonly');\n        // this.setAttribute('readonly','readonly');\n        this.classList.toggle('readonly');\n        this._dispatchEvent('readonly');\n      }\n      if (!this.modelItem.readonly) {\n        this.widget.removeAttribute('readonly');\n        // this.removeAttribute('readonly');\n        this.classList.toggle('readonly');\n        this._dispatchEvent('readwrite');\n      }\n    }\n  }\n\n  // todo - review alert handling altogether. There could be potentially multiple ones in model\n  handleValid() {\n    // console.log('mip valid', this.modelItem.required);\n    const alert = this.querySelector('fx-alert');\n\n    if (this.isValid() !== this.modelItem.constraint) {\n      if (this.modelItem.constraint) {\n        this.classList.remove('invalid');\n        if (alert) alert.style.display = 'none';\n        this._dispatchEvent('valid');\n      } else {\n        // ### constraint is invalid - handle alerts\n        this.classList.add('invalid');\n        if (alert) {\n          alert.style.display = 'block';\n        }\n        if (this.modelItem.alerts.length !== 0) {\n          const { alerts } = this.modelItem;\n          console.log('alerts from bind: ', alerts);\n\n          const controlAlert = this.querySelector('fx-alert');\n          if (!controlAlert) {\n            alerts.forEach(modelAlert => {\n              const newAlert = document.createElement('fx-alert');\n              newAlert.innerHTML = modelAlert;\n              this.appendChild(newAlert);\n              newAlert.style.display = 'block';\n            });\n          }\n        }\n\n        // this.dispatchEvent(new CustomEvent('invalid', {}));\n        this._dispatchEvent('invalid');\n      }\n    }\n  }\n\n  handleRelevant() {\n    // console.log('mip valid', this.modelItem.enabled);\n    if (this.isEnabled() !== this.modelItem.relevant) {\n      if (this.modelItem.relevant) {\n        this._dispatchEvent('relevant');\n        this._fadeIn(this, this.display);\n      } else {\n        this._dispatchEvent('nonrelevant');\n        this._fadeOut(this);\n      }\n    }\n  }\n\n  isRequired() {\n    if (this.widget.hasAttribute('required')) {\n      return true;\n    }\n    return false;\n  }\n\n  isValid() {\n    if (this.classList.contains('invalid')) {\n      return false;\n    }\n    return true;\n  }\n\n  isReadonly() {\n    // const widget = this.querySelector('#widget');\n    if (this.widget.hasAttribute('readonly')) {\n      return true;\n    }\n    return false;\n  }\n\n  isEnabled() {\n    // if(this.style.display === 'none' || this.classList.contains('non-relevant')){\n    if (this.style.display === 'none') {\n      return false;\n    }\n    return true;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  _fadeOut(el) {\n    el.style.opacity = 1;\n\n    (function fade() {\n      // eslint-disable-next-line no-cond-assign\n      if ((el.style.opacity -= 0.1) < 0) {\n        el.style.display = 'none';\n      } else {\n        requestAnimationFrame(fade);\n      }\n    })();\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  _fadeIn(el, display) {\n    el.style.opacity = 0;\n    el.style.display = display || 'block';\n\n    (function fade() {\n      let val = parseFloat(el.style.opacity);\n      // eslint-disable-next-line no-cond-assign\n      if (!((val += 0.1) > 1)) {\n        el.style.opacity = val;\n        requestAnimationFrame(fade);\n      }\n    })();\n  }\n}\n\nwindow.customElements.define('fx-abstract-control', AbstractControl);\n","import { html, css } from 'lit-element';\n\nimport XfAbstractControl from './abstract-control.js';\n\nexport class FxAlert extends XfAbstractControl {\n  static get styles() {\n    return css`\n      :host {\n        display: block;\n        height: auto;\n        font-size: 0.8em;\n        font-weight: 400;\n        color: red;\n        display: none;\n      }\n    `;\n  }\n\n  constructor() {\n    super();\n    this.style.display = 'none';\n  }\n\n  static get properties() {\n    return {\n      ...super.properties,\n    };\n  }\n\n  render() {\n    return html`\n      <slot></slot>\n    `;\n  }\n\n  async updateWidgetValue() {\n    console.log('alert update', this);\n    this.innerHTML = this.value;\n  }\n}\ncustomElements.define('fx-alert', FxAlert);\n","import XfAbstractControl from './abstract-control.js';\nimport { evaluateXPath, evaluateXPathToString } from '../xpath-evaluation.js';\n\nconst WIDGETCLASS = 'widget';\n\n/**\n * `fx-control`\n * a generic wrapper for controls\n *\n *\n *\n * @customElement\n * @demo demo/index.html\n */\nclass FxControl extends XfAbstractControl {\n  constructor() {\n    super();\n    this.inited = false;\n    this.attachShadow({ mode: 'open' });\n  }\n\n  connectedCallback() {\n    this.updateEvent = this.hasAttribute('update-event')\n      ? this.getAttribute('update-event')\n      : 'blur';\n    this.valueProp = this.hasAttribute('value-prop') ? this.getAttribute('value-prop') : 'value';\n    this.label = this.hasAttribute('label') ? this.getAttribute('label') : null;\n    const style = `\n            :host{\n                display:inline-block;\n            }\n        `;\n\n    /*\n        const controlHtml = `\n            <slot></slot>\n            <fx-setvalue id=\"setvalue\" ref=\"${this.ref}\"></fx-setvalue>\n        `;\n*/\n\n    /*\n        this.shadowRoot.innerHTML = `\n            <style>\n                ${style}\n            </style>\n            ${controlHtml}\n        `\n*/\n    this.shadowRoot.innerHTML = `\n            <style>\n                ${style}\n            </style>\n            ${this.renderHTML(this.ref)}\n        `;\n\n    this.widget = this.getWidget();\n    console.log('widget ', this.widget);\n\n    // ### convenience marker event\n    if (this.updateEvent === 'enter') {\n      this.widget.addEventListener('keyup', event => {\n        if (event.keyCode === 13) {\n          // Cancel the default action, if needed\n          event.preventDefault();\n          this.setValue(this.widget[this.valueProp]);\n        }\n        // console.log('enter handler ', this.updateEvent);\n        // this.setValue(this.widget[this.valueProp]);\n      });\n      this.updateEvent = 'blur'; // needs to be registered too\n    }\n    this.widget.addEventListener(this.updateEvent, () => {\n      console.log('eventlistener ', this.updateEvent);\n      this.setValue(this.widget[this.valueProp]);\n    });\n  }\n\n  setValue(val) {\n    const modelitem = this.getModelItem();\n    const setval = this.shadowRoot.getElementById('setvalue');\n    setval.setValue(modelitem, val);\n    setval.actionPerformed();\n  }\n\n  renderHTML(ref) {\n    return `\n            ${this.label ? `${this.label}` : ''}\n            <slot></slot>\n            <fx-setvalue id=\"setvalue\" ref=\"${ref}\"></fx-setvalue>\n        `;\n  }\n\n  /**\n   *\n   * @returns {HTMLElement|*}\n   */\n  getWidget() {\n    let widget = this.querySelector(`.${WIDGETCLASS}`);\n    if (!widget) {\n      widget = this.querySelector('input');\n    }\n    if (!widget) {\n      const input = document.createElement('input');\n      input.classList.add(WIDGETCLASS);\n      input.setAttribute('type', 'text');\n      this.appendChild(input);\n      return input;\n    }\n    return widget;\n  }\n\n  // todo: check again\n  async updateWidgetValue() {\n    // this.widget[this.valueProp] = this.value;\n    if (this.valueProp === 'checked') {\n      if (this.value === 'true') {\n        this.widget.checked = true;\n      } else {\n        this.widget.checked = false;\n      }\n    } else {\n      let { widget } = this;\n      if (!widget) {\n        widget = this;\n      }\n      widget.value = this.value;\n    }\n  }\n\n  async refresh() {\n    super.refresh();\n    // const {widget} = this;\n\n    // ### if we find a ref on control we have a 'select' control of some kind\n    // todo: review - seems a bit implicite to draw that 'itemset decision' just from the existence of a 'ref'\n    if (this.widget.hasAttribute('ref')) {\n      const tmpl = this.widget.querySelector('template');\n\n      // ### eval nodeset for list control\n      const ref = this.widget.getAttribute('ref');\n      const inscope = this.getInScopeContext();\n      const formElement = this.closest('fx-fore');\n      const nodeset = evaluateXPath(ref, inscope, formElement);\n\n      // ### clear items\n      const { children } = this.widget;\n      Array.from(children).forEach(child => {\n        if (child.nodeName.toLowerCase() !== 'template') {\n          child.parentNode.removeChild(child);\n        }\n      });\n\n      // ### build the items\n      Array.from(nodeset).forEach(node => {\n        console.log('#### node', node);\n        const content = tmpl.content.firstElementChild.cloneNode(true);\n        const newEntry = document.importNode(content, true);\n        // console.log('newEntry ', newEntry);\n        this.widget.appendChild(newEntry);\n\n        // ### initialize new entry\n        // ### set value\n        const valueAttribute = this._getValueAttribute(newEntry);\n        const valueExpr = valueAttribute.value;\n        const cutted = valueExpr.substring(1, valueExpr.length - 1);\n        const evaluated = evaluateXPath(cutted, node, formElement);\n        valueAttribute.value = evaluated;\n\n        if (this.value === evaluated) {\n          newEntry.setAttribute('selected', 'selected');\n        }\n\n        // ### set label\n        const optionLabel = newEntry.textContent;\n        const labelExpr = optionLabel.substring(1, optionLabel.length - 1);\n\n        const label = evaluateXPathToString(labelExpr, node, formElement);\n        newEntry.textContent = label;\n      });\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  _getValueAttribute(element) {\n    let result;\n    Array.from(element.attributes).forEach(attribute => {\n      const attrVal = attribute.value;\n      if (attrVal.indexOf('{') !== -1) {\n        // console.log('avt found ', attribute);\n        result = attribute;\n      }\n    });\n    return result;\n  }\n}\n\nwindow.customElements.define('fx-control', FxControl);\n","import '../fx-model.js';\nimport { Fore } from '../fore.js';\nimport { foreElementMixin } from '../ForeElementMixin.js';\n\n/**\n * `fx-container` -\n * is a general class for container elements.\n *\n */\nexport class FxContainer extends foreElementMixin(HTMLElement) {\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n  }\n\n  connectedCallback() {\n    const style = `\n        :host {\n            display: block;\n        }\n    `;\n\n    const html = `\n      <slot></slot>\n    `;\n\n    this.shadowRoot.innerHTML = `\n            <style>\n                ${style}\n            </style>\n            ${html}\n    `;\n  }\n\n  /**\n   * (re)apply all state properties to this control.\n   */\n  refresh() {\n    console.log('### FxContainer.refresh on : ', this);\n\n    if (this.isBound()) {\n      this.evalInContext();\n      this.modelItem = this.getModelItem();\n      this.value = this.modelItem.value;\n    }\n\n    // await this.updateComplete;\n\n    // state change event do not fire during init phase (initial refresh)\n    if (this._getForm().ready) {\n      this.handleModelItemProperties();\n    }\n    Fore.refreshChildren(this);\n  }\n\n  handleModelItemProperties() {\n    this.handleReadonly();\n    this.handleRelevant();\n  }\n\n  _getForm() {\n    return this.getModel().parentNode;\n  }\n\n  handleReadonly() {\n    // console.log('mip readonly', this.modelItem.isReadonly);\n    if (this.isReadonly() !== this.modelItem.readonly) {\n      if (this.modelItem.readonly) {\n        this.setAttribute('readonly', 'readonly');\n        this.dispatchEvent(new CustomEvent('readonly', {}));\n      }\n      if (!this.modelItem.readonly) {\n        this.removeAttribute('readonly');\n        this.dispatchEvent(new CustomEvent('readwrite', {}));\n      }\n    }\n  }\n\n  handleRelevant() {\n    // console.log('mip valid', this.modelItem.enabled);\n    if (this.isEnabled() !== this.modelItem.enabled) {\n      if (this.modelItem.enabled) {\n        this.dispatchEvent(new CustomEvent('enabled', {}));\n      } else {\n        this.dispatchEvent(new CustomEvent('disabled', {}));\n      }\n    }\n  }\n\n  isReadonly() {\n    if (this.hasAttribute('readonly')) {\n      return true;\n    }\n    return false;\n  }\n\n  isEnabled() {\n    if (this.style.display === 'none') {\n      return false;\n    }\n    return true;\n  }\n}\n\nwindow.customElements.define('fx-container', FxContainer);\n","import { html } from 'lit-element';\nimport { Fore } from '../fore.js';\n// import XfAbstractControl from \"./fx-abstract-control\";\nimport { FxContainer } from './fx-container.js';\n\n/**\n * `fx-group`\n * a container allowing to switch between fx-case elements\n *\n *\n *  * todo: implement\n * @customElement\n */\nclass FxGroup extends FxContainer {\n  static get properties() {\n    return {\n      ...super.properties,\n      collapse: {\n        type: Boolean,\n        reflect: true,\n      },\n    };\n  }\n  /*\n            init(model){\n                super.init(model);\n                console.log(this, this.modelItem);\n\n                // this.initializeChildren(this);\n            }\n        */\n\n  constructor() {\n    super();\n    this.collapse = false;\n  }\n\n  render() {\n    return html`\n      <slot></slot>\n    `;\n  }\n\n  /**\n   * overwrites Abstract Control.\n   *\n   * Groups only reacts to 'relevant' property.\n   */\n  handleModelItemProperties() {\n    this.handleRelevant();\n  }\n\n  initializeChildren(node) {\n    const children = Array.from(node.children);\n    console.log('_initializeChildren ', children);\n\n    children.forEach(child => {\n      console.log('child ', child);\n\n      if (Fore.isUiElement(child.nodeName)) {\n        child.init(this.model);\n      } else if (child.children.length !== 0) {\n        const grantChildren = Array.from(child.children);\n        grantChildren.forEach(grantChild => {\n          this.initializeChildren(grantChild);\n        });\n      }\n    });\n    /*\n                if(Fore.isUiElement(node.nodeName)){\n                    const childElements = children.filter( action => Fore.isUiElement(action.nodeName));\n                    console.log('children ', childElements);\n                    console.group('init children');\n                    if(childElements.length > 0){\n                        childElements.forEach( child => {\n                            console.log('action ', child);\n                            child.init(this.model);\n                        });\n                    }\n                }else if(node){\n                    this._initializeChildren(node);\n                }\n        */\n\n    console.groupEnd();\n  }\n}\n\nwindow.customElements.define('fx-group', FxGroup);\n","import { html, css } from 'lit-element';\n\nimport XfAbstractControl from './abstract-control.js';\n\nexport class FxHint extends XfAbstractControl {\n  static get styles() {\n    return css`\n      :host {\n        display: block;\n        height: auto;\n        font-size: 0.8em;\n        font-weight: 400;\n        font-style: italic;\n      }\n    `;\n  }\n\n  static get properties() {\n    return {\n      ...super.properties,\n    };\n  }\n\n  render() {\n    return html`\n      <slot></slot>\n    `;\n  }\n\n  /*\n  isRequired() {\n    return false;\n  }\n\n  isReadonly () {\n    return true;\n  }\n*/\n\n  /*\n  handleRequired () {}\n\n  handleReadonly () {\n    // super.handleReadonly();\n  }\n*/\n}\ncustomElements.define('fx-hint', FxHint);\n","import XfAbstractControl from './abstract-control.js';\n\n/**\n * todo: review placing of value. should probably work with value attribute and not allow slotted content.\n */\nexport class FxOutput extends XfAbstractControl {\n  static get properties() {\n    return {\n      ...super.properties,\n      valueAttr: {\n        type: String,\n      },\n    };\n  }\n\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.valueAttr = this.hasAttribute('value') ? this.getAttribute('value') : null;\n  }\n\n  connectedCallback() {\n    console.log('connectedCallback output', this.shadowRoot);\n\n    const style = `\n          :host {\n            display: inline-block;\n          }\n          #widget {\n            display: inline-block;\n          }\n          .label{\n            display: inline-block;\n          }\n        `;\n\n    const outputHtml = `\n            <slot name=\"label\"></slot>\n            <span id=\"value\">\n                <slot></slot>\n            </span>\n        `;\n\n    this.shadowRoot.innerHTML = `\n            <style>\n                ${style}\n            </style>\n            ${outputHtml}\n        `;\n    // this.widget = this.shadowRoot.querySelector('#widget');\n    // this.widget = this.getWidget();\n    // console.log('widget ', this.widget);\n\n    this.addEventListener('slotchange', e => {\n      console.log('slotchange ', e);\n    });\n  }\n\n  async refresh() {\n    // ### 1. eval 'value' attr\n\n    if (this.valueAttr) {\n      this.value = this.getValue();\n      await this.updateWidgetValue();\n      return;\n    }\n    // ### 2. eval 'ref' attr\n    if (this.ref) {\n      super.refresh();\n    }\n    // ### 3. use inline content which is there anyway\n  }\n\n  getWidget() {\n    const valueWrapper = this.shadowRoot.getElementById('value');\n    return valueWrapper;\n  }\n\n  async updateWidgetValue() {\n    const valueWrapper = this.shadowRoot.getElementById('value');\n    valueWrapper.innerHTML = this.value;\n  }\n\n  isReadonly() {\n    this.readonly = true;\n    return this.readonly;\n  }\n}\n\ncustomElements.define('fx-output', FxOutput);\n","import { Fore } from '../fore.js';\nimport { foreElementMixin } from '../ForeElementMixin.js';\n\n/**\n * `fx-repeat`\n * an xformish form for eXist-db\n *\n * @customElement\n * @demo demo/index.html\n */\nexport class FxRepeatitem extends foreElementMixin(HTMLElement) {\n  static get properties() {\n    return {\n      inited: {\n        type: Boolean,\n      },\n    };\n  }\n\n  constructor() {\n    super();\n    this.inited = false;\n\n    this.addEventListener('click', this._dispatchIndexChange);\n    this.addEventListener('focusin', this._handleFocus);\n\n    this.attachShadow({ mode: 'open', delegatesFocus: true });\n  }\n\n  _handleFocus() {\n    this.parentNode.setIndex(this.index);\n  }\n\n  _dispatchIndexChange() {\n    // console.log('_dispatchIndexChange on index ', this.index);\n    if (this.parentNode) {\n      this.parentNode.dispatchEvent(\n        new CustomEvent('item-changed', { composed: true, bubbles: true, detail: { item: this } }),\n      );\n    }\n  }\n\n  connectedCallback() {\n    this.display = this.style.display;\n\n    const html = `\n           <slot></slot>\n        `;\n\n    this.shadowRoot.innerHTML = `\n            ${html}\n        `;\n  }\n\n  disconnectedCallback() {\n    // console.log('disconnectedCallback ', this);\n    this.removeEventListener('click', this._dispatchIndexChange());\n    this.removeEventListener('focusin', this._handleFocus);\n  }\n\n  init() {\n    // console.log('repeatitem init model ', this.nodeset);\n    // this._initializeChildren(this);\n    this.inited = true;\n  }\n\n  getModelItem() {\n    super.getModelItem();\n    // console.log('modelItem in repeatitem ', this.getModelItem()[this.index]);\n    return this.getModelItem()[this.index];\n  }\n\n  refresh() {\n    // console.log('refresh repeatitem: ',this.nodeset);\n    // console.log('refresh repeatitem nodeset: ',this.nodeset);\n    this.modelItem = this.getModel().getModelItem(this.nodeset);\n\n    if (this.modelItem && !this.modelItem.relevant) {\n      this.style.display = 'none';\n    } else {\n      this.style.display = this.display;\n    }\n\n    /*\n    if (this?.modelItem?.relevant) {\n      // Fore.refreshChildren(this);\n    } else {\n    }\n*/\n\n    Fore.refreshChildren(this);\n  }\n}\n\nwindow.customElements.define('fx-repeatitem', FxRepeatitem);\n","import './fx-repeatitem.js';\n\nimport { Fore } from '../fore.js';\nimport { foreElementMixin } from '../ForeElementMixin.js';\nimport { evaluateXPath } from '../xpath-evaluation.js';\nimport getInScopeContext from '../getInScopeContext.js';\n\n/**\n * `fx-repeat`\n *\n * Repeats its template for each node in its' bound nodeset.\n *\n * Template is a standard HTML `<template>` element. Once instanciated the template\n * is moved to the shadowDOM of the repeat for safe re-use.\n *\n *\n *\n * @customElement\n * @demo demo/todo.html\n */\nexport class FxRepeat extends foreElementMixin(HTMLElement) {\n  static get properties() {\n    return {\n      ...super.properties,\n      index: {\n        type: Number,\n      },\n      template: {\n        type: Object,\n      },\n      focusOnCreate: {\n        type: String,\n      },\n      initDone: {\n        type: Boolean,\n      },\n      repeatIndex: {\n        type: Number,\n      },\n      nodeset: {\n        type: Array,\n      },\n    };\n  }\n\n  constructor() {\n    super();\n    this.ref = '';\n    this.dataTemplate = [];\n    this.focusOnCreate = '';\n    this.initDone = false;\n    this.repeatIndex = 1;\n    this.nodeset = [];\n    this.inited = false;\n    this.index = 1;\n    this.repeatSize = 0;\n    this.attachShadow({ mode: 'open', delegatesFocus: true });\n  }\n\n  get repeatSize() {\n    return this.querySelectorAll(':scope > fx-repeatitem').length;\n  }\n\n  set repeatSize(size) {\n    this.size = size;\n  }\n\n  setIndex(index) {\n    // console.log('new repeat index ', index);\n    this.index = index;\n    const rItems = this.querySelectorAll(':scope > fx-repeatitem');\n    this.applyIndex(rItems[this.index - 1]);\n  }\n\n  applyIndex(repeatItem) {\n    this._removeIndexMarker();\n    if (repeatItem) {\n      repeatItem.setAttribute('repeat-index', '');\n    }\n  }\n\n  get index() {\n    return this.getAttribute('index');\n  }\n\n  set index(idx) {\n    this.setAttribute('index', idx);\n  }\n\n  connectedCallback() {\n    this.ref = this.getAttribute('ref');\n    // console.log('### fx-repeat connected ', this.id);\n    this.addEventListener('item-changed', e => {\n      console.log('handle index event ', e);\n      const { item } = e.detail;\n      const idx = Array.from(this.children).indexOf(item);\n      this.applyIndex(this.children[idx]);\n      this.index = idx + 1;\n    });\n    // todo: review - this is just used by append action - event consolidation ?\n    this.addEventListener('index-changed', e => {\n      e.stopPropagation();\n      if (!e.target === this) return;\n      console.log('handle index event ', e);\n      // const { item } = e.detail;\n      // const idx = Array.from(this.children).indexOf(item);\n      const { index } = e.detail;\n      this.index = index;\n      this.applyIndex(this.children[index - 1]);\n    });\n    document.addEventListener('insert', e => {\n      const nodes = e.detail.insertedNodes;\n      this.index = e.detail.position;\n      console.log('insert catched', nodes, this.index);\n    });\n\n    const style = `\n             .fade-out-bottom {\n                -webkit-animation: fade-out-bottom 0.7s cubic-bezier(0.250, 0.460, 0.450, 0.940) both;\n                animation: fade-out-bottom 0.7s cubic-bezier(0.250, 0.460, 0.450, 0.940) both;\n            }\n            .fade-out-bottom {\n                -webkit-animation: fade-out-bottom 0.7s cubic-bezier(0.250, 0.460, 0.450, 0.940) both;\n                animation: fade-out-bottom 0.7s cubic-bezier(0.250, 0.460, 0.450, 0.940) both;\n            }\n        `;\n    const html = `\n          <slot name=\"header\"></slot>\n          <slot></slot>\n        `;\n    this.shadowRoot.innerHTML = `\n            <style>\n                ${style}\n            </style>\n            ${html}\n        `;\n  }\n\n  init() {\n    // ### there must be a single 'template' child\n    // console.log('##### repeat init ', this.id);\n    // if(!this.inited) this.init();\n    // does not use this.evalInContext as it is expecting a nodeset instead of single node\n    this._evalNodeset();\n    // console.log('##### ',this.id, this.nodeset);\n\n    this._initTemplate();\n    this._initRepeatItems();\n\n    this.setAttribute('index', this.index);\n    this.inited = true;\n  }\n\n  /**\n   * repeat has no own modelItems\n   * @private\n   */\n  _evalNodeset() {\n    // const inscope = this.getInScopeContext();\n    const inscope = getInScopeContext(this, this.ref);\n    // console.log('##### inscope ', inscope);\n    // console.log('##### ref ', this.ref);\n\n    const seq = evaluateXPath(this.ref, inscope, this.getOwnerForm());\n    // const seq = evaluateXPathToNodes(this.ref, inscope, this.getOwnerForm());\n    if (seq === null) {\n      // Empty sequence\n      this.nodeset = [];\n      return;\n    }\n\n    if (typeof seq === 'object') {\n      // Either a node or an array\n      if ('nodeType' in seq) {\n        // Node\n        this.nodeset = [seq];\n        return;\n      }\n\n      // if (Array.isArray(seq) && seq.every(item => typeof item === 'object')) {\n      if (Array.isArray(seq)) {\n        // multiple Nodes or maps\n        this.nodeset = seq;\n        return;\n      }\n    }\n\n    throw new Error(`Unexpected result of repeat nodeset: ${seq}`);\n  }\n\n  async refresh() {\n    console.group('fx-repeat.refresh on', this.id);\n\n    if (!this.inited) this.init();\n    this._evalNodeset();\n    // console.log('repeat refresh nodeset ', this.nodeset);\n\n    const repeatItems = this.querySelectorAll(':scope > fx-repeatitem');\n    const repeatItemCount = repeatItems.length;\n\n    let nodeCount = 1;\n    if (Array.isArray(this.nodeset)) {\n      nodeCount = this.nodeset.length;\n    }\n\n    // const contextSize = this.nodeset.length;\n    const contextSize = nodeCount;\n    // todo: review - cant the context really never be smaller than the repeat count?\n    // todo: this code can be deprecated probably but check first\n    if (contextSize < repeatItemCount) {\n      for (let position = repeatItemCount; position > contextSize; position -= 1) {\n        // remove repeatitem\n        const itemToRemove = repeatItems[position - 1];\n        itemToRemove.parentNode.removeChild(itemToRemove);\n\n        // this._fadeOut(itemToRemove);\n      }\n    }\n\n    if (contextSize > repeatItemCount) {\n      for (let position = repeatItemCount + 1; position <= contextSize; position += 1) {\n        // add new repeatitem\n\n        const newItem = document.createElement('fx-repeatitem');\n        const clonedTemplate = this._clone();\n        newItem.appendChild(clonedTemplate);\n        this.appendChild(newItem);\n\n        newItem.nodeset = this.nodeset[position - 1];\n        newItem.index = position;\n      }\n    }\n\n    // ### update nodeset of repeatitems\n    for (let position = 0; position < repeatItemCount; position += 1) {\n      const item = repeatItems[position];\n      if (item.nodeset !== this.nodeset[position]) {\n        item.nodeset = this.nodeset[position];\n      }\n    }\n\n    this._fadeIn(repeatItems[this.index - 1]);\n    Fore.refreshChildren(this);\n    this.setIndex(this.index);\n    console.groupEnd();\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  _fadeOut(el) {\n    el.style.opacity = 1;\n\n    (function fade() {\n      // eslint-disable-next-line no-cond-assign\n      if ((el.style.opacity -= 0.1) < 0) {\n        el.style.display = 'none';\n      } else {\n        requestAnimationFrame(fade);\n      }\n    })();\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  _fadeIn(el) {\n    if (!el) return;\n\n    el.style.opacity = 0;\n    el.style.display = this.display;\n\n    (function fade() {\n      // setTimeout(() => {\n      let val = parseFloat(el.style.opacity);\n      // eslint-disable-next-line no-cond-assign\n      if (!((val += 0.1) > 1)) {\n        el.style.opacity = val;\n        requestAnimationFrame(fade);\n      }\n      // }, 40);\n    })();\n  }\n\n  _initTemplate() {\n    // const shadowTemplate = this.shadowRoot.querySelector('template');\n    // console.log('shadowtempl ', shadowTemplate);\n\n    // const defaultSlot = this.shadowRoot.querySelector('slot');\n    // todo: this is still weak - should handle that better maybe by an explicit slot?\n    // this.template = this.firstElementChild;\n    this.template = this.querySelector('template');\n    console.log('### init template for repeat ', this.id, this.template);\n\n    if (this.template === null) {\n      // console.error('### no template found for this repeat:', this.id);\n      // todo: catch this on form element\n      this.dispatchEvent(\n        new CustomEvent('no-template-error', {\n          composed: true,\n          bubbles: true,\n          detail: { message: `no template found for repeat:${this.id}` },\n        }),\n      );\n    }\n\n    this.shadowRoot.appendChild(this.template);\n  }\n\n  _initRepeatItems() {\n    // const model = this.getModel();\n    // this.textContent = '';\n    this.nodeset.forEach((item, index) => {\n      const repeatItem = document.createElement('fx-repeatitem');\n      repeatItem.nodeset = this.nodeset[index];\n      repeatItem.index = index + 1; // 1-based index\n\n      const clone = this._clone();\n      repeatItem.appendChild(clone);\n      this.appendChild(repeatItem);\n\n      if (repeatItem.index === 1) {\n        this.applyIndex(repeatItem);\n      }\n    });\n  }\n\n  _clone() {\n    // const content = this.template.content.cloneNode(true);\n    this.template = this.shadowRoot.querySelector('template');\n    const content = this.template.content.cloneNode(true);\n    return document.importNode(content, true);\n  }\n\n  _removeIndexMarker() {\n    Array.from(this.children).forEach(item => {\n      item.removeAttribute('repeat-index');\n    });\n  }\n}\n\nwindow.customElements.define('fx-repeat', FxRepeat);\n","import { Fore } from '../fore.js';\nimport { FxContainer } from './fx-container.js';\n\n/**\n * `fx-switch`\n * a container allowing to switch between fx-case elements\n *\n *  * todo: implement\n * @customElement\n */\nclass FxSwitch extends FxContainer {\n  /*\n      constructor() {\n        super();\n        // this.attachShadow({ mode: 'open' });\n      }\n    */\n\n  connectedCallback() {\n    if (super.connectedCallback) {\n      super.connectedCallback();\n    }\n    const style = `\n       :host ::slotted(fx-case.selected-case){\n        display: block !important;\n    }\n    `;\n    const html = `\n       <slot></slot>\n    `;\n    this.shadowRoot.innerHTML = `\n        <style>\n            ${style}\n        </style>\n        ${html}\n    `;\n  }\n\n  refresh() {\n    super.refresh();\n    console.log('refresh on switch ');\n    const cases = this.querySelectorAll('fx-case');\n    if (this.isBound()) {\n      Array.from(cases).forEach(caseElem => {\n        const name = caseElem.getAttribute('name');\n        if (name === this.modelItem.value) {\n          caseElem.classList.add('selected-case');\n        } else {\n          caseElem.classList.remove('selected-case');\n        }\n      });\n    } else {\n      const selected = this.querySelector('.selected-case');\n      if (!selected) {\n        cases[0].classList.add('selected-case');\n      }\n    }\n\n    Fore.refreshChildren(this);\n    // console.log('value ', this.value);\n  }\n\n  toggle(caseElement) {\n    const cases = this.querySelectorAll('fx-case');\n    Array.from(cases).forEach(c => {\n      if (caseElement === c) {\n        // eslint-disable-next-line no-param-reassign\n        c.classList.add('selected-case');\n      } else {\n        // eslint-disable-next-line no-param-reassign\n        c.classList.remove('selected-case');\n      }\n    });\n  }\n}\n\nwindow.customElements.define('fx-switch', FxSwitch);\n","import XfAbstractControl from './abstract-control.js';\n\nexport class FxTrigger extends XfAbstractControl {\n  connectedCallback() {\n    this.attachShadow({ mode: 'open' });\n    this.ref = this.hasAttribute('ref') ? this.getAttribute('ref') : null;\n    const style = `\n          :host {\n            cursor:pointer;\n          }\n        `;\n\n    this.shadowRoot.innerHTML = `\n                <style>\n                    ${style}\n                </style>\n                ${this.renderHTML()}\n        `;\n\n    const slot = this.shadowRoot.querySelector('slot');\n    slot.addEventListener('slotchange', () => {\n      const elements = slot.assignedElements({ flatten: true });\n      elements[0].setAttribute('tabindex', '0');\n      elements[0].setAttribute('role', 'button');\n\n      const element = elements[0];\n      element.addEventListener('click', e => this.performActions(e));\n      this.widget = element;\n      // # terrible hack but browser behaves strange - seems to fire a 'click' for a button when it receives a\n      // # 'Space' or 'Enter' key\n      if (element.nodeName !== 'BUTTON') {\n        element.addEventListener('keypress', e => {\n          if (e.code === 'Space' || e.code === 'Enter') {\n            this.performActions(e);\n          }\n        });\n      }\n    });\n    /*\n            this.addEventListener('click', e => this.performActions(e));\n            this.addEventListener('keypress', (e) => {\n                if(e.code === 'Space' || e.code === 'Enter'){\n                    this.performActions(e);\n                }\n            });\n    */\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  renderHTML() {\n    return `\n            <slot></slot>\n    `;\n  }\n\n  getWidget() {\n    return this.widget;\n  }\n\n  async updateWidgetValue() {\n    console.log('trigger update', this);\n    return null;\n  }\n\n  handleReadonly() {\n    super.handleReadonly();\n    // ### add disabled attribute in case we're readonly. This is special behavior of fx-trigger\n    if (this.widget.hasAttribute('readonly')) {\n      this.widget.setAttribute('disabled', 'disabled');\n    } else {\n      this.widget.removeAttribute('disabled');\n    }\n  }\n\n  async performActions(e) {\n    // todo: support readonly for trigger not executing the action\n    const repeatedItem = this.closest('fx-repeatitem');\n    if (repeatedItem) {\n      console.log('repeated click');\n      repeatedItem.click();\n    }\n\n    const forLoop = async () => {\n      for (let i = 0; i < this.children.length; i += 1) {\n        const child = this.children[i];\n        if (typeof child.execute === 'function') {\n          // eslint-disable-next-line no-await-in-loop\n          await child.execute(e);\n        }\n      }\n    };\n    forLoop();\n  }\n\n  /*\n        async refresh() {\n          super.refresh();\n          // console.log('fx-button refresh');\n\n          const elements = this.querySelectorAll(':scope > *');\n          elements.forEach(element => {\n            if (typeof element.refresh === 'function') {\n              element.refresh();\n            }\n          });\n        }\n      */\n}\n\ncustomElements.define('fx-trigger', FxTrigger);\n","// import { foreElementMixin } from '../ForeElementMixin';\n\n/**\n * `fx-case`\n * a container allowing to switch between fx-case elements\n *\n *  * todo: implement\n * @customElement\n */\nclass FxCase extends HTMLElement {\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n  }\n\n  connectedCallback() {\n    if (this.hasAttribute('label')) {\n      this.label = this.getAttribute('label');\n    }\n    if (this.hasAttribute('name')) {\n      this.name = this.getAttribute('name');\n    }\n    if (this.hasAttribute('selected')) {\n      this.selected = this.getAttribute('selected');\n    }\n\n    const style = `\n            :host {\n                display: none;\n            }\n        `;\n    const html = `\n           ${this.label ? `<span>${this.label}</span>` : ''}\n           <slot></slot>\n        `;\n    this.shadowRoot.innerHTML = `\n            <style>\n                ${style}\n            </style>\n            ${html}\n    `;\n\n    this.style.display = 'none';\n  }\n}\n\nwindow.customElements.define('fx-case', FxCase);\n","import { foreElementMixin } from '../ForeElementMixin.js';\nimport { evaluateXPathToBoolean } from '../xpath-evaluation.js';\n\nasync function wait(howLong) {\n  return new Promise(resolve => setTimeout(() => resolve(), howLong));\n}\n\n/**\n * Superclass for all action elements. Provides basic wiring of events to targets as well as\n * handle conditionals and loops of actions.\n *\n * @fires action-performed - is dispatched after each execution of an action.\n * @customElement\n * @demo demo/index.html\n */\nexport class AbstractAction extends foreElementMixin(HTMLElement) {\n  static get properties() {\n    return {\n      ...super.properties,\n      /**\n       * detail - event detail object\n       */\n      detail: {\n        type: Object,\n      },\n      /**\n       * wether nor not an action needs to run the update cycle\n       */\n      needsUpdate: {\n        type: Boolean,\n      },\n      /**\n       * event to listen for\n       */\n      event: {\n        type: Object,\n      },\n      /**\n       * id of target element to attach listener to\n       */\n      target: {\n        type: String,\n      },\n      /**\n       * boolean XPath expression. If true the action will be executed.\n       */\n      ifExpr: {\n        type: String,\n      },\n      /**\n       * boolean XPath expression. If true loop will be executed. If an ifExpr is present this also needs to be true\n       * to actually run the action.\n       */\n      whileExpr: {\n        type: String,\n      },\n      /**\n       * delay before executing action in milliseconds\n       */\n      delay: {\n        type: Number,\n      },\n    };\n  }\n\n  constructor() {\n    super();\n    this.detail = {};\n    this.needsUpdate = false;\n  }\n\n  connectedCallback() {\n    this.style.display = 'none';\n    this.repeatContext = undefined;\n\n    if (this.hasAttribute('event')) {\n      this.event = this.getAttribute('event');\n    } else {\n      this.event = 'activate';\n    }\n\n    this.target = this.getAttribute('target');\n    if (this.target) {\n      if (this.target === '#document') {\n        document.addEventListener(this.event, e => this.execute(e));\n      } else {\n        this.targetElement = document.getElementById(this.target);\n        this.targetElement.addEventListener(this.event, e => this.execute(e));\n      }\n    } else {\n      this.targetElement = this.parentNode;\n      this.targetElement.addEventListener(this.event, e => this.execute(e));\n      // console.log('adding listener for ', this.event , ` to `, this);\n    }\n\n    this.ifExpr = this.hasAttribute('if') ? this.getAttribute('if') : null;\n    this.whileExpr = this.hasAttribute('while') ? this.getAttribute('while') : null;\n    this.delay = this.hasAttribute('delay') ? Number(this.getAttribute('delay')) : 0;\n  }\n\n  /**\n   * executes the action.\n   *\n   * Will first evaluate ifExpr and continue only if it evaluates to 'true'. The 'whileExpr' will be executed\n   * considering the delay if present.\n   *\n   * After calling `perform' which actually implements the semantics of an concrete action\n   * `actionPerformed` will make sure that update cycle is run if 'needsUpdate' is true.\n   *\n   * @param e\n   */\n  async execute(e) {\n    console.log('executing', this);\n    if (e && e.detail) {\n      this.detail = e.detail;\n    }\n    this.needsUpdate = false;\n\n    this.evalInContext();\n    if (this.targetElement && this.targetElement.nodeset) {\n      this.nodeset = this.targetElement.nodeset;\n    }\n\n    // First check if 'if' condition is true - otherwise exist right away\n    if (this.ifExpr && !evaluateXPathToBoolean(this.ifExpr, this.nodeset, this.getOwnerForm())) {\n      return;\n    }\n\n    if (this.whileExpr) {\n      // While: while the condition is true, delay a bit and execute the action\n      const loop = async () => {\n        // Start by waiting\n        await wait(this.delay || 0);\n\n        if (!this.ownerDocument.contains(this)) {\n          // We are no longer in the document. Stop working\n          return;\n        }\n\n        if (!evaluateXPathToBoolean(this.whileExpr, this.nodeset, this.getOwnerForm())) {\n          // Done with iterating\n          return;\n        }\n\n        // Perform the action once\n        this.perform();\n\n        // Go for one more iteration\n        await loop();\n      };\n\n      // After loop is done call actionPerformed to update the model and UI\n      await loop();\n      this.actionPerformed();\n      return;\n    }\n\n    if (this.delay) {\n      // Delay further execution until the delay is done\n      await wait(this.delay);\n      if (!this.ownerDocument.contains(this)) {\n        // We are no longer in the document. Stop working\n        this.actionPerformed();\n        return;\n      }\n    }\n\n    this.perform();\n    this.actionPerformed();\n  }\n\n  /**\n   * Template method to be implemented by each action that is called by execute() as part of\n   * the processing.\n   *\n   * todo: review - this could probably just be empty or throw error signalling that extender needs to implement it\n   */\n  perform() {\n    if (this.isBound() || this.nodeName === 'FX-ACTION') {\n      this.evalInContext();\n    }\n  }\n\n  /**\n   * calls the update cycle if action signalled that update is needed.\n   */\n  actionPerformed() {\n    // console.log('actionPerformed action parentNode ', this.parentNode);\n    if (this.needsUpdate) {\n      const model = this.getModel();\n      model.recalculate();\n      model.revalidate();\n      model.parentNode.refresh();\n      this._dispatchActionPerformed();\n    }\n  }\n\n  /**\n   * @private\n   */\n  _dispatchActionPerformed() {\n    console.log('action-performed ', this);\n    this.dispatchEvent(\n      new CustomEvent('action-performed', { composed: true, bubbles: true, detail: {} }),\n    );\n  }\n}\n\nwindow.customElements.define('abstract-action', AbstractAction);\n","import { AbstractAction } from './abstract-action.js';\nimport { Fore } from '../fore.js';\n\n/**\n * `fx-append` appends an entry to a repeat.\n *\n *\n *\n * @deprecated - will be replaced with `fx-insert`\n * @fires index-changed - fired after new item is appended\n * @customElement\n */\n// class FxAppend extends FxAction {\nclass FxAppend extends AbstractAction {\n  static get properties() {\n    return {\n      ref: {\n        type: String,\n      },\n      /**\n       * the repeat this action is appending to.\n       */\n      repeat: {\n        type: String,\n      },\n      clear: {\n        type: String,\n      },\n    };\n  }\n\n  constructor() {\n    super();\n    this.repeat = '';\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n    console.log('connectedCallback ', this);\n    this.ref = this.getAttribute('ref');\n    this.repeat = this.getAttribute('repeat');\n    // this.repeated = this.closest('fx-repeatitem');\n  }\n\n  /**\n   * appends a instance of the repeat template to the existing ones.\n   *\n   * The data structure to insert into the instance data is determined by the 'ref' attributes\n   * found in the template of the repeat. This is similar to lazy instance creation.\n   *\n   * Note: This is a significant difference to XForms which takes the instance nodes as template to insert but\n   * has the problem of empty nodesets not being able to insert an entry without using a separate instance\n   * holding the template.\n   *\n   * As a consequence the item that are appended are not propagated with values but empty. However usually\n   * that's what the user wants and not the other way round (duplicating the last data items). If the XForms\n   * behavior should be needed for some reason later on, it can be added easier by a providing an 'duplicate' action.\n   *\n   */\n  perform() {\n    super.perform();\n\n    this._dataFromTemplate();\n    /*\n        const instData = new XMLSerializer().serializeToString(\n            this.getModel()\n                .getDefaultInstance()\n                .getInstanceData(),\n        );\n*/\n    // console.log('modified instance ', this.getModel().getDefaultInstance().getInstanceData());\n\n    this.needsUpdate = true;\n  }\n\n  actionPerformed() {\n    super.actionPerformed();\n    // const repeat = document.getElementById(this.repeat);\n    // repeat.setIndex(repeat.nodeset.length);\n    this.dispatch();\n  }\n\n  /**\n   * creates a data-template from repeat template and appends it to inscope context instance.\n   *\n   * @private\n   */\n  _dataFromTemplate() {\n    const inscope = this.getInScopeContext();\n    const parentForm = this.getOwnerForm();\n    const repeat = parentForm.querySelector(`#${this.repeat}`);\n    // console.log('_dataFromTemplate repeat', repeat);\n    // console.log('_dataFromTemplate repeat ref', repeat.ref);\n\n    const templ = repeat.shadowRoot.querySelector('template');\n    // console.log('_dataFromTemplate ', templ);\n    // console.log('_dataFromTemplate content', templ.content);\n\n    // iterate template for refs\n    // todo: will fail for pathes with predicates - need to be filtered before\n    // const rootNode = document.createElement(repeat.ref);\n\n    // const rootNode = document.createElement(repeat.ref);\n    // const rootNode = inscope.ownerDocument.createElement(repeat.ref);\n    const rootNode = inscope.ownerDocument.createElement(repeat.ref);\n\n    // const data = this._dataFromRefs(rootNode, templ.content)\n    const data = this._generateInstance(templ.content, rootNode);\n    // console.log('_dataFromTemplate DATA', data);\n    inscope.appendChild(data);\n    // console.log('appended new item ', data);\n    // return data;\n  }\n\n  /**\n   * dispatches set-index event to target repeat\n   *\n   * The target repeat is a child of the same repeat-item as the append action.\n   */\n  dispatch() {\n    let targetRepeat;\n    if (Fore.isRepeated(this)) {\n      console.log('append repeated ', this.repeatContext);\n      targetRepeat = Fore.getRepeatTarget(this, this.repeat);\n    } else {\n      targetRepeat = document.getElementById(this.repeat);\n    }\n    console.log('dispatching index change ', targetRepeat.nodeset.length);\n    targetRepeat.dispatchEvent(\n      new CustomEvent('index-changed', {\n        composed: true,\n        bubbles: true,\n        detail: { index: targetRepeat.nodeset.length },\n      }),\n    );\n  }\n\n  /**\n   * clear all text nodes and attribute values to get a 'clean' template.\n   * @param n\n   * @private\n   *\n   *\n   */\n  _clear(n) {\n    let node = n.firstChild;\n    const attrs = n.attributes;\n    for (let i = 0; i < attrs.length; i += 1) {\n      // n.setAttribute(attrs[i].name,'');\n      attrs[i].value = '';\n    }\n    while (node) {\n      if (node.nodeType === 1 && node.hasAttributes()) {\n        node.textContent = '';\n      }\n      this._clear(node);\n      node = node.nextSibling;\n    }\n  }\n\n  _generateInstance(start, parent) {\n    if (start.nodeType === 1 && start.hasAttribute('ref')) {\n      const ref = start.getAttribute('ref');\n\n      let generated;\n      if (ref === '.') {\n        // node.appendChild(document.createElement(repeatRef));\n      } else if (ref.startsWith('@')) {\n        parent.setAttribute(ref.substring(1), '');\n      } else {\n        generated = document.createElement(ref);\n        parent.appendChild(generated);\n        if (start.children.length === 0) {\n          generated.textContent = start.textContent;\n        }\n      }\n    }\n\n    if (start.hasChildNodes()) {\n      const list = start.children;\n      for (let i = 0; i < list.length; i += 1) {\n        this._generateInstance(list[i], parent);\n      }\n    }\n    return parent;\n  }\n\n  getInstanceId() {\n    if (this.ref.startsWith('instance(')) {\n      return 'not implemented';\n    }\n    return 'default';\n  }\n\n  /*\n    _fadeIn (el, display) {\n      // eslint-disable-next-line no-param-reassign\n      el.style.opacity = 0;\n      // eslint-disable-next-line no-param-reassign\n      el.style.display = display || 'block';\n\n      (function fade() {\n        // let val = parseFloat(el.style.opacity);\n        let val = parseFloat(el.style.opacity);\n        val += 0.1;\n        if (!(val > 1)) {\n          // eslint-disable-next-line no-param-reassign\n          el.style.opacity = val;\n          requestAnimationFrame(fade);\n        }\n      })();\n    }\n  */\n}\n\nwindow.customElements.define('fx-append', FxAppend);\n","import { AbstractAction } from './abstract-action.js';\n\n/**\n * `fx-delete`\n * general class for bound elements\n *\n * @customElement\n * @demo demo/todo.html\n */\nclass FxDelete extends AbstractAction {\n  constructor() {\n    super();\n    this.repeatId = '';\n  }\n\n  /**\n   * deletes a\n   */\n  perform() {\n    super.perform();\n    console.log('##### fx-delete executing...');\n\n    // this.ref = this.getAttribute('ref');\n    // const inscope = this.getInScopeContext();\n    // this.nodeset = fx.evaluateXPathToNodes(this.ref, inscope, null, {});\n\n    console.log('delete nodeset ', this.nodeset);\n\n    // ### if there's no repeat the delete action is inside of a repeat template\n    if (this.repeatId === '') {\n      // find the index to delete\n      const rItem = this.parentNode.closest('fx-repeatitem');\n      const idx = Array.from(rItem.parentNode.children).indexOf(rItem) + 1;\n      // console.log('>>> idx to delete ', idx);\n\n      // ### get the model now as it'll be hard once we've deleted ourselves ;)\n      this.model = this.getModel();\n      const repeat = this.parentNode.closest('fx-repeat');\n\n      // ### update the nodeset\n      let nodeToDelete;\n      if (Array.isArray(this.nodeset)) {\n        nodeToDelete = this.nodeset[idx - 1];\n      } else {\n        nodeToDelete = this.nodeset;\n      }\n      const p = nodeToDelete.parentNode;\n      p.removeChild(nodeToDelete);\n\n      // ### remove the repeatitem\n      rItem.parentNode.removeChild(rItem);\n\n      // ### update the index (set 'repeat-index' attribute on repeatitem\n      const { repeatSize } = repeat;\n      if (idx === 1 || repeatSize === 1) {\n        repeat.setIndex(1);\n      } else if (idx > repeatSize) {\n        repeat.setIndex(repeatSize);\n      } else {\n        repeat.setIndex(idx);\n      }\n    }\n\n    // this.needsRebuild = true;\n    // this.needsRecalculate = true;\n    // this.needsRevalidate = true;\n    // this.needsRefresh = true;\n\n    this.needsUpdate = true;\n\n    // this.actionPerformed();\n  }\n\n  actionPerformed() {\n    this.getModel().rebuild();\n    super.actionPerformed();\n  }\n}\n\nwindow.customElements.define('fx-delete', FxDelete);\n","import { AbstractAction } from './abstract-action.js';\nimport getInScopeContext from '../getInScopeContext.js';\nimport {\n  evaluateXPath,\n  evaluateXPathToNodes,\n  evaluateXPathToFirstNode,\n  evaluateXPathToNumber,\n} from '../xpath-evaluation.js';\n\n/**\n * `fx-insert`\n * inserts nodes into data instances\n *\n * @customElement\n */\nexport class FxInsert extends AbstractAction {\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n  }\n\n  connectedCallback() {\n    if (super.connectedCallback) {\n      super.connectedCallback();\n    }\n    const style = `\n        :host{\n            display:none;\n        }\n    `;\n    this.shadowRoot.innerHTML = `\n        <style>\n            ${style}\n        </style>\n        <slot></slot>\n    `;\n\n    this.at = Number(this.hasAttribute('at') ? this.getAttribute('at') : 0); // default: size of nodeset, determined later\n    this.position = this.hasAttribute('position') ? this.getAttribute('position') : 'after';\n    this.origin = this.hasAttribute('origin') ? this.getAttribute('origin') : null; // last item of context seq\n    this.keepValues = !!this.hasAttribute('keep-values');\n  }\n\n  _cloneOriginSequence(inscope, targetSequence) {\n    let originSequenceClone;\n    if (this.origin) {\n      // ### if there's an origin attribute use it\n      let originTarget;\n      try {\n        originTarget = evaluateXPathToFirstNode(this.origin, inscope, this.getOwnerForm());\n        if (Array.isArray(originTarget) && originTarget.length === 0) {\n          console.warn('invalid origin for this insert action - ignoring...', this);\n          originSequenceClone = null;\n        }\n        originSequenceClone = originTarget.cloneNode(true);\n      } catch (error) {\n        console.warn('invalid origin for this insert action - ignoring...', this);\n      }\n    } else if (targetSequence) {\n      // ### use last item of targetSequence\n      originSequenceClone = this._cloneTargetSequence(targetSequence);\n      if (originSequenceClone && !this.keepValues) {\n        this._clear(originSequenceClone);\n      }\n    }\n    return originSequenceClone;\n  }\n\n  _getInsertIndex(inscope, targetSequence) {\n    if (targetSequence.length === 0) {\n      return null;\n    }\n    if (this.hasAttribute('at')) {\n      return evaluateXPathToNumber(this.getAttribute('at'), inscope, this.getOwnerForm());\n    }\n    return targetSequence.length;\n  }\n\n  perform() {\n    super.perform();\n\n    /*\n         todo: !!! calling super here does not correctly give the nodeset - it's likely still a bug in ForeElementMixin !!!\n        // super.perform();\n        console.log('this.nodeset', this.nodeset);\n        */\n\n    // ### obtaining targetSequence\n    const inscope = getInScopeContext(this, this.ref);\n\n    // @ts-ignore\n    const targetSequence = evaluateXPathToNodes(this.ref, inscope, this.getOwnerForm());\n    console.log('insert nodeset ', targetSequence);\n\n    // ### obtaining originSequence\n    /*\n        let originSequence;\n        if (this.origin) {\n            // ### if there's an origin attribute use it\n            const originTarget = evaluateXPathToFirstNode(this.origin, inscope, this.getOwnerForm());\n            if(Array.isArray(originTarget) && originTarget.length === 0){\n                console.warn('invalid origin for this insert action - ignoring...', this);\n                return;\n            }\n            originSequence = originTarget.cloneNode(true);\n        } else if (targetSequence) {\n            // ### use last item of targetSequence\n            originSequence = this._cloneTargetSequence(targetSequence);\n            if(originSequence && !this.keepValues){\n                this._clear(originSequence);\n            }\n        }\n*/\n    const originSequenceClone = this._cloneOriginSequence(inscope, targetSequence);\n    if (!originSequenceClone) return; // if no origin back out without effect\n\n    let insertLocationNode;\n    let index;\n\n    const idx = this._getInsertIndex(inscope, targetSequence);\n    console.log('insert index', idx);\n\n    // if the targetSequence is empty but we got an originSequence use inscope as context and ignore 'at' and 'position'\n    if (targetSequence.length === 0) {\n      insertLocationNode = inscope;\n      inscope.appendChild(originSequenceClone);\n      index = 1;\n      console.log('appended', inscope);\n    } else {\n      // todo: eval 'at'\n\n      /*\n            insert at position given by 'at' or use the last item in the targetSequence\n             */\n      // if (this.at) {\n      if (this.hasAttribute('at')) {\n        // index = this.at;\n        // insertLocationNode = targetSequence[this.at - 1];\n\n        index = evaluateXPathToNumber(this.getAttribute('at'), inscope, this.getOwnerForm());\n        insertLocationNode = targetSequence[index - 1];\n      } else {\n        // this.at = targetSequence.length;\n        index = targetSequence.length;\n        insertLocationNode = targetSequence[targetSequence.length - 1];\n      }\n\n      // ### if the insertLocationNode is undefined use the targetSequence - usually the case when the targetSequence just contains a single node\n      if (!insertLocationNode) {\n        index = 1;\n\n        insertLocationNode = targetSequence;\n        const context = evaluateXPath('count(preceding::*)', targetSequence, this.getOwnerForm());\n        console.log('context', context);\n        index = context + 1;\n        // index = targetSequence.findIndex(insertLocationNode);\n      }\n\n      if (this.position && this.position === 'before') {\n        // this.at -= 1;\n        insertLocationNode.parentNode.insertBefore(originSequenceClone, insertLocationNode);\n      }\n\n      if (this.position && this.position === 'after') {\n        // insertLocationNode.parentNode.append(originSequence);\n        // const nextSibl = insertLocationNode.nextSibling;\n        index += 1;\n        insertLocationNode.insertAdjacentElement('afterend', originSequenceClone);\n      }\n    }\n\n    // console.log('insert context item ', insertLocationNode);\n    // console.log('parent ', insertLocationNode.parentNode);\n    console.log('instance ', this.getModel().getDefaultContext());\n\n    console.log('<<<<<<< at', this.at);\n    console.log('<<<<<<< index', index);\n    document.dispatchEvent(\n      new CustomEvent('insert', {\n        composed: true,\n        bubbles: true,\n        detail: { insertedNodes: originSequenceClone, position: index },\n      }),\n    );\n\n    this.needsUpdate = true;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  _cloneTargetSequence(seq) {\n    if (Array.isArray(seq) && seq.length !== 0) {\n      return seq[seq.length - 1].cloneNode(true);\n    }\n    if (!Array.isArray(seq) && seq) {\n      return seq.cloneNode(true);\n    }\n    return null;\n  }\n\n  actionPerformed() {\n    this.getModel().rebuild();\n    super.actionPerformed();\n  }\n\n  /**\n   * clear all text nodes and attribute values to get a 'clean' template.\n   * @param n\n   * @private\n   */\n  _clear(n) {\n    const attrs = n.attributes;\n\n    // clear attrs\n    for (let i = 0; i < attrs.length; i += 1) {\n      // n.setAttribute(attrs[i].name,'');\n      attrs[i].value = '';\n    }\n    // clear text content\n    if (n.textContent) {\n      n.textContent = '';\n    }\n\n    let node = n.firstChild;\n    while (node) {\n      if (node.nodeType === 1 && node.hasAttributes()) {\n        node.textContent = '';\n      }\n      this._clear(node);\n      node = node.nextSibling;\n    }\n  }\n}\n\nwindow.customElements.define('fx-insert', FxInsert);\n","import { AbstractAction } from './abstract-action.js';\n\n/**\n * `fx-message`\n *\n * Action to display messages to the user.\n *\n *\n */\nclass FxMessage extends AbstractAction {\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n    this.event = this.hasAttribute('event') ? this.getAttribute('event') : '';\n    this.level = this.hasAttribute('level') ? this.getAttribute('level') : 'ephemeral';\n    const style = `\n        :host{\n            display:none;\n        }\n    `;\n    this.shadowRoot.innerHTML = `\n        <style>\n            ${style}\n        </style>\n        ${this.renderHTML()}\n    `;\n  }\n\n  disconnectedCallback() {\n    // super.disconnectedCallback();\n    this.targetElement.removeEventListener(this.event, e => this.execute(e));\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  renderHTML() {\n    return `\n        <slot></slot>\n    `;\n  }\n\n  perform() {\n    super.perform();\n    let message;\n    if (this.hasAttribute('value')) {\n      message = this.getValue();\n    } else {\n      message = this.textContent;\n    }\n\n    this.dispatchEvent(\n      new CustomEvent('message', {\n        composed: true,\n        bubbles: true,\n        detail: { level: this.level, message },\n      }),\n    );\n  }\n}\n\nwindow.customElements.define('fx-message', FxMessage);\n","// import { FxAction } from './fx-action.js';\nimport '../fx-model.js';\nimport { AbstractAction } from './abstract-action.js';\nimport { evaluateXPath } from '../xpath-evaluation.js';\n\n/**\n * `fx-setvalue`\n *\n * @customElement\n */\nexport default class FxSetvalue extends AbstractAction {\n  static get properties() {\n    return {\n      ...super.properties,\n      ref: {\n        type: String,\n      },\n      valueAttr: {\n        type: String,\n      },\n    };\n  }\n\n  constructor() {\n    super();\n    this.ref = '';\n    this.valueAttr = '';\n  }\n\n  connectedCallback() {\n    if (super.connectedCallback) {\n      super.connectedCallback();\n    }\n\n    if (this.hasAttribute('ref')) {\n      this.ref = this.getAttribute('ref');\n    } else {\n      throw new Error('fx-setvalue must specify a \"ref\" attribute');\n    }\n    this.valueAttr = this.getAttribute('value');\n  }\n\n  perform() {\n    super.perform();\n    let { value } = this;\n    if (this.valueAttr !== null) {\n      value = evaluateXPath(this.valueAttr, this.nodeset, this.getOwnerForm(), this.detail);\n    } else if (this.textContent !== '') {\n      value = this.textContent;\n    } else {\n      value = '';\n    }\n    const mi = this.getModelItem();\n    this.setValue(mi, value);\n  }\n\n  setValue(modelItem, newVal) {\n    console.log('setvalue[1]  ', modelItem, newVal);\n\n    const item = modelItem;\n    if (!item) return;\n\n    if (item.value !== newVal) {\n      item.value = newVal;\n      item.changed = true;\n\n      this.needsUpdate = true;\n\n      console.log('setvalue[2] ', item, newVal);\n    }\n  }\n}\n\nwindow.customElements.define('fx-setvalue', FxSetvalue);\n","import '../fx-model.js';\nimport '../fx-submission.js';\nimport { AbstractAction } from './abstract-action.js';\n\n/**\n * `fx-send` - finds and activates a `fx-submission` element.\n *\n *\n * @customElement\n */\nclass FxSend extends AbstractAction {\n  constructor() {\n    super();\n    this.value = '';\n  }\n\n  connectedCallback() {\n    // eslint-disable-next-line wc/guard-super-call\n    super.connectedCallback();\n    console.log('connectedCallback ', this);\n    this.submission = this.getAttribute('submission');\n  }\n\n  perform() {\n    super.perform();\n\n    console.log('submitting ', this.submission);\n    console.log('submitting model', this.getModel());\n\n    // if not exists signal error\n    const submission = this.getModel().querySelector(`#${this.submission}`);\n    if (submission === null) {\n      this.dispatchEvent(\n        new CustomEvent('error', {\n          composed: true,\n          bubbles: true,\n          detail: { message: `fx-submission element with id: '${this.submission}' not found` },\n        }),\n      );\n      throw new Error(`submission with id: ${this.submission} not found`);\n    }\n    console.log('submission', submission);\n    submission.submit();\n    // if not of type fx-submission signal error\n  }\n}\n\nwindow.customElements.define('fx-send', FxSend);\n","import { AbstractAction } from './abstract-action.js';\n\n/**\n * `fx-action`\n * an action to wrap other actions and defers the update cycle until the end of the block.\n *\n * @customElement\n * @demo demo/index.html\n */\nexport class FxAction extends AbstractAction {\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n  }\n\n  connectedCallback() {\n    if (super.connectedCallback) {\n      super.connectedCallback();\n    }\n    this.src = this.hasAttribute('src') ? this.getAttribute('src') : null;\n    const style = `\n        :host{\n            display:none;\n        }\n    `;\n    this.shadowRoot.innerHTML = `\n        <style>\n            ${style}\n        </style>\n        <slot></slot>\n    `;\n  }\n\n  perform() {\n    const { children } = this;\n\n    if (this.src) {\n      this.innerHTML = ''; // reset\n      console.log('### fx-script.perform ');\n      const script = document.createElement('script');\n      script.src = this.src;\n      this.appendChild(script);\n    } else {\n      Array.from(children).forEach(action => {\n        action.detail = this.detail;\n        // action.perform();\n        action.execute();\n      });\n      // this.needsUpdate = false;\n    }\n  }\n}\n\nwindow.customElements.define('fx-action', FxAction);\n","import { FxAction } from './fx-action.js';\n\n/**\n * `fx-toggle`\n *\n */\nclass FxToggle extends FxAction {\n  connectedCallback() {\n    if (this.hasAttribute('case')) {\n      this.case = this.getAttribute('case');\n    }\n  }\n\n  /*\n    disconnectedCallback() {\n        super.disconnectedCallback();\n    }\n\n*/\n  execute() {\n    console.log('### fx-toggle.execute ');\n    if (this.case) {\n      const ownerForm = this.getOwnerForm();\n      const caseElement = ownerForm.querySelector(`#${this.case}`);\n      const fxSwitch = caseElement.parentNode;\n      fxSwitch.toggle(caseElement);\n    }\n  }\n}\n\nwindow.customElements.define('fx-toggle', FxToggle);\n","import { AbstractAction } from './abstract-action.js';\nimport { evaluateXPath } from '../xpath-evaluation.js';\n\n/**\n * `fx-dispatch`\n *\n * dispatches an event with optional details.\n *\n * Properties given by `fx-property` child elements are stored to the events' details object and\n * can be accessed in usual JavaScript way.\n */\nexport class FxDispatch extends AbstractAction {\n  constructor() {\n    super();\n    this.name = null;\n    this.targetid = null;\n    this.details = null;\n    this.attachShadow({ mode: 'open' });\n  }\n\n  /**\n   * checks for `event` attribute. If not present will throw an Error\n   *\n   * @throws Error when no `event` attribute is given\n   */\n  connectedCallback() {\n    super.connectedCallback();\n    this.name = this.getAttribute('name');\n    if (!this.name) {\n      throw new Error('no event specified for dispatch', this);\n    }\n\n    this.targetid = this.hasAttribute('targetid') ? this.getAttribute('targetid') : null;\n\n    // ### has a shadow just to hide\n    /*\n    this.shadowRoot.innerHTML = `\n        <style>\n            :host *{\n                display: none;\n            }\n        </style>\n        <slot></slot>\n    `;\n*/\n  }\n\n  /*\n    disconnectedCallback() {\n        super.disconnectedCallback();\n    }\n\n*/\n\n  perform() {\n    console.log('### fx-dispatch.perform ', this);\n\n    const properties = this.querySelectorAll('fx-property');\n    const details = {};\n    Array.from(properties).forEach(prop => {\n      console.log('prop ', prop);\n      const name = prop.getAttribute('name');\n      const value = prop.getAttribute('value');\n      const expr = prop.getAttribute('expr');\n\n      if (expr) {\n        if (value) {\n          throw new Error('if \"expr\" is given there must not be a \"value\" attribute');\n        }\n        const result = evaluateXPath(expr, this.getInScopeContext(), this.getOwnerForm());\n        let serialized = null;\n        if (result.nodeName) {\n          const serializer = new XMLSerializer();\n          serialized = serializer.serializeToString(result);\n        }\n        if (serialized) {\n          details[name] = serialized;\n        } else {\n          details[name] = result;\n        }\n      }\n\n      if (value) {\n        details[name] = value;\n      }\n    });\n\n    console.log('details ', details);\n\n    // ### when targetid is given dispatch to that if present (throw an error if not) - otherwise dispatch to document\n    if (this.targetid) {\n      const target = document.getElementById(this.targetid);\n      if (!target) {\n        throw new Error(`targetid ${this.targetid} does not exist in document`);\n      }\n      target.dispatchEvent(\n        new CustomEvent(this.name, {\n          composed: true,\n          bubbles: true,\n          detail: details,\n        }),\n      );\n    } else {\n      document.dispatchEvent(\n        new CustomEvent(this.name, {\n          composed: true,\n          bubbles: true,\n          detail: details,\n        }),\n      );\n    }\n  }\n}\n\nwindow.customElements.define('fx-dispatch', FxDispatch);\n","import { AbstractAction } from './abstract-action.js';\n\n/**\n * `fx-update`\n *\n * Calls updateModel() on fx-model which in turn will rebuild, recalculate and revalidate.\n *\n */\nclass FxUpdate extends AbstractAction {\n  perform() {\n    this.getModel().updateModel();\n  }\n}\n\nwindow.customElements.define('fx-update', FxUpdate);\n","import { AbstractAction } from './abstract-action.js';\n\n/**\n * `fx-refresh`\n *\n * Calls refresh() on fx-form\n *\n */\nclass FxRefresh extends AbstractAction {\n  perform() {\n    this.getOwnerForm().refresh();\n  }\n}\n\nwindow.customElements.define('fx-refresh', FxRefresh);\n","import { FxAction } from './fx-action.js';\n\n/**\n * `fx-confirm`\n * Displays a simple confirmation before actually executing the nested actions.\n *\n * @customElement\n * @demo demo/project.html\n */\nexport class FxConfirm extends FxAction {\n  connectedCallback() {\n    this.message = this.hasAttribute('message') ? this.getAttribute('message') : null;\n  }\n\n  perform() {\n    if (window.confirm(this.message)) {\n      super.perform();\n    }\n  }\n}\n\nwindow.customElements.define('fx-confirm', FxConfirm);\n","import { registerCustomXPathFunction } from 'fontoxpath';\nimport { foreElementMixin } from '../ForeElementMixin.js';\nimport { evaluateXPath } from '../xpath-evaluation.js';\n\n/**\n * Allows to extend a form with local custom functions.\n *\n * ` */\nexport class FxFunction extends foreElementMixin(HTMLElement) {\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n  }\n\n  connectedCallback() {\n    this.style.display = 'none';\n\n    this.signature = this.hasAttribute('signature') ? this.getAttribute('signature') : null;\n    if (this.signature === null) {\n      console.error('signature is a required attribute');\n    }\n    this.type = this.hasAttribute('type') ? this.getAttribute('type') : null;\n    this.shadowRoot.innerHTML = `<slot></slot>`;\n\n    this.override = this.hasAttribute('override') ? this.getAttribute('override') : 'true';\n    this.functionBody = this.innerText;\n\n    const type = this.getAttribute('type') || 'text/xpath';\n\n    // Parse the signature to something useful\n    // Signature is of the form `my:sumproduct($p as xs:decimal*, $q as xs:decimal*) as xs:decimal`\n    const signatureParseResult = this.signature.match(\n      /(?:(?<prefix>[^:]*):)?(?<localName>[^(]+)\\((?<params>[^)]*)\\)(?: as (?<returnType>.*))?/,\n    );\n\n    if (!signatureParseResult) {\n      throw new Error(`Function signature ${this.signature} could not be parsed`);\n    }\n\n    const { prefix, localName, params, returnType } = signatureParseResult.groups;\n\n    // TODO: lookup prefix\n    const functionIdentifier =\n      prefix === 'local'\n        ? { namespaceURI: 'http://www.w3.org/2005/xquery-local-functions', localName }\n        : `${prefix}:${localName}`;\n\n    const paramParts = params\n      ? params.split(',').map(param => {\n          const match = param.match(/(?<variableName>\\$[^\\s]+)(?:\\sas\\s(?<varType>.+))/);\n          if (!match) {\n            throw new Error(`Param ${param} could not be parsed`);\n          }\n          const { variableName, varType } = match.groups;\n          return {\n            variableName,\n            variableType: varType || 'item()*',\n          };\n        })\n      : [];\n\n    switch (type) {\n      case 'text/javascript': {\n        // eslint-disable-next-line no-new-func\n        const fun = new Function(\n          '_domFacade',\n          ...paramParts.map(paramPart => paramPart.variableName),\n          'form',\n          this.functionBody,\n        );\n        registerCustomXPathFunction(\n          functionIdentifier,\n          paramParts.map(paramPart => paramPart.variableType),\n          returnType || 'item()*',\n          (...args) => fun.apply(this.getInScopeContext(), [...args, this.getOwnerForm()]),\n        );\n        break;\n      }\n\n      case 'text/xpath': {\n        const fun = (domFacade, ...args) =>\n          evaluateXPath(\n            this.functionBody,\n            this.getInScopeContext(),\n            this.getOwnerForm(),\n            paramParts.reduce((variablesByName, paramPart, i) => {\n              variablesByName[paramPart.variableName.replace('$', '')] = args[i];\n              return variablesByName;\n            }, {}),\n          );\n        registerCustomXPathFunction(\n          functionIdentifier,\n          paramParts.map(paramPart => paramPart.variableType),\n          returnType || 'item()*',\n          fun,\n        );\n        break;\n      }\n\n      default:\n        throw new Error(`Unexpected mimetype ${type} for function`);\n    }\n  }\n}\ncustomElements.define('fx-function', FxFunction);\n"],"names":["DependencyNotifyingDomFacade","constructor","onNodeTouched","_onNodeTouched","getAllAttributes","node","Array","from","attributes","getAttribute","attributeName","getChildNodes","bucket","childNodes","filter","childNode","getBucketsForNode","includes","getData","nodeType","Node","ATTRIBUTE_NODE","value","parentNode","data","getFirstChild","matchingNode","this","getLastChild","matchingNodes","matchNode","length","getNextSibling","nextSibling","getParentNode","getPreviousSibling","previousSibling","XPathUtil","path","startsWith","ref","result","substring","indexOf","fx","instanceId","ownerDocument","firstElementChild","shortenPath","steps","split","i","step","createDFS","edges","leavesOnly","circular","visited","start","inCurrentPath","currentPath","todo","push","processed","current","pop","window","dispatchEvent","CustomEvent","composed","bubbles","detail","message","nodeEdges","DepGraph","opts","nodes","outgoingEdges","incomingEdges","prototype","size","Object","keys","addNode","hasNode","arguments","removeNode","forEach","edgeList","key","idx","splice","hasOwnProperty","call","getNodeData","Error","setNodeData","addDependency","to","removeDependency","clone","source","n","slice","directDependenciesOf","directDependantsOf","dependenciesOf","DFS","dependantsOf","overallOrder","self","CycleDFS","directDependentsOf","dependentsOf","Fore","elementName","ACTION_ELEMENTS","UI_ELEMENTS","startElement","Promise","resolve","children","element","isUiElement","nodeName","refresh","toUpperCase","refreshChildren","closest","id","querySelector","instance","method","type","console","warn","READONLY_DEFAULT","REQUIRED_DEFAULT","RELEVANT_DEFAULT","CONSTRAINT_DEFAULT","TYPE_DEFAULT","XFORMS_NAMESPACE_URI","registerCustomXPathFunction","namespaceURI","localName","dynamicContext","string","formElement","currentContext","XMLSerializer","serializeToString","getDefaultContext","tree","document","createElement","setAttribute","form","logtree","removeChild","appendChild","buildTree","ELEMENT_NODE","details","summary","contents","display","attr","nodeValue","firstChild","TEXT_NODE","trim","textContent","childElementCount","child","xhtmlNamespaceResolver","prefix","fxEvaluateXPathToFirstNode","namespaceResolver","inst","functionNameResolver","_arity","resolveNamespacePrefix","contextElement","fxEvaluateXPathToString","log","evaluateXPath","xpath","contextNode","variables","fxEvaluateXPath","moduleImports","xf","evaluateXPathToFirstNode","defaultFunctionNamespaceURI","evaluateXPathToNodes","fxEvaluateXPathToNodes","evaluateXPathToBoolean","fxEvaluateXPathToBoolean","evaluateXPathToString","domFacade","namespaceReferenceNode","evaluateXPathToNumber","fxEvaluateXPathToNumber","repeat","arg","registerXQueryModule","btoa","FxInstance","HTMLElement","model","attachShadow","mode","connectedCallback","hasAttribute","src","shadowRoot","innerHTML","_initInstance","then","evalXPath","parentElement","getInstanceData","instanceData","_createInstanceData","setInstanceData","query","URLSearchParams","location","search","doc","DOMParser","parseFromString","root","p","newNode","createTextNode","_loadData","_useInlineData","url","contentType","getContentType","fetch","credentials","headers","response","responseContentType","get","toLowerCase","text","json","catch","error","_getContentType","JSON","parse","_handleResponse","ajax","getElementById","lastResponse","_handleError","loader","lastError","customElements","define","ModelItem","readonly","relevant","required","constraint","bind","changed","alerts","newVal","DOCUMENT_NODE","addAlert","alert","cleanAlerts","FxModel","instances","modelItems","defaultContext","inited","modelConstructed","addEventListener","e","targetNode","getPath","mi","registerModelItem","modelConstruct","querySelectorAll","group","promises","init","all","updateModel","groupEnd","modelItem","rebuild","recalculate","revalidate","mainGraph","getModelItem","property","compute","expr","valid","getAlert","find","m","getDefaultInstance","getDefaultInstanceData","getInstance","evalBinding","bindingExpr","_getForeContext","_getInitialContext","parentBind","nodeset","getModel","_getModelInContext","isAbsolutePath","getInstanceId","getInScopeContext","ownerElement","_getParentElement","repeatItem","initialContext","foreElementMixin","superclass","context","String","getOwnerForm","currentElement","DocumentFragment","host","evalInContext","inscopeContext","isArray","isSelfReference","localResult","isNotBound","isBound","getBindingExpr","parent","instId","_getParentBindingElement","existed","index","lazyCreateModelItem","getValue","valAttr","dispatch","eventName","event","FxBind","calculate","_getInstanceId","bindType","_evalInContext","_buildBindGraph","_createModelItems","_processChildren","calculateRefs","_getReferencesForProperty","_addDependencies","readonlyRefs","requiredRefs","relevantRefs","constraintRefs","_addNode","refs","nodeHash","otherPath","childbinds","alertChild","item","_createModelItem","parentBoundElement","newItem","propertyExpr","touchedNodes","Set","otherNode","add","values","_initBooleanModelItemProperty","bindExpr","FxFore","ready","Boolean","_handleModelConstructDone","_displayMessage","_displayError","storedTemplateExpressionByNode","Map","modelElement","target","assignedElements","modelElem","generatedModel","evaluateToNodes","disconnectedCallback","_updateTemplateExpressions","tmplExpressions","has","_getTemplateExpression","set","_processTemplateExpression","exprObj","evaluateTemplateExpression","matches","match","namespaceContextNode","naked","inscope","replaced","replaceAll","errNode","_refreshChildren","_initUI","generatedInstance","generated","implementation","createDocument","_generateInstance","isActionElement","_generateNode","hasChildNodes","list","_lazyCreateInstance","level","msg","_showMessage","showToast","innerText","classList","FxSubmission","methods","nonrelevant","replace","serialization","targetref","mediatype","validate","renderHTML","submission","_submit","_serializeAndSend","_evaluateAttributeTemplateExpression","resolvedUrl","serialized","undefined","selectRelevant","_serialize","_getHeaders","body","xml","blob","ok","status","instanceType","relevantNodes","params","append","Headers","delete","headerElems","header","name","val","_getUrlExpr","storedTemplateExpressions","stored","_getTargetInstance","targetInstance","theTarget","replaceChild","getElementsByTagName","href","_isRelevant","_filterRelevant","cloneNode","removeAttribute","FxHeader","style","AbstractControl","widget","getWidget","currentVal","updateWidgetValue","handleModelItemProperties","handleRequired","handleReadonly","handleValid","handleRelevant","_getForm","_dispatchEvent","isRequired","toggle","isReadonly","isValid","remove","modelAlert","newAlert","isEnabled","_fadeIn","_fadeOut","contains","el","opacity","fade","requestAnimationFrame","parseFloat","XfAbstractControl","css","super","properties","render","html","updateEvent","valueProp","label","keyCode","preventDefault","setValue","modelitem","setval","actionPerformed","input","checked","tmpl","content","newEntry","importNode","valueAttribute","_getValueAttribute","valueExpr","evaluated","optionLabel","attribute","FxContainer","enabled","collapse","reflect","initializeChildren","grantChild","valueAttr","FxRepeatitem","_dispatchIndexChange","_handleFocus","delegatesFocus","setIndex","removeEventListener","FxRepeat","Number","template","focusOnCreate","initDone","repeatIndex","dataTemplate","repeatSize","rItems","applyIndex","_removeIndexMarker","stopPropagation","insertedNodes","position","_evalNodeset","_initTemplate","_initRepeatItems","seq","repeatItems","repeatItemCount","nodeCount","contextSize","itemToRemove","clonedTemplate","_clone","cases","caseElem","caseElement","c","slot","elements","flatten","performActions","code","repeatedItem","click","async","execute","forLoop","FxCase","selected","wait","howLong","setTimeout","AbstractAction","needsUpdate","ifExpr","whileExpr","delay","repeatContext","targetElement","loop","perform","_dispatchActionPerformed","clear","_dataFromTemplate","templ","rootNode","targetRepeat","isRepeated","getRepeatTarget","_clear","attrs","hasAttributes","repeatId","rItem","nodeToDelete","at","origin","keepValues","_cloneOriginSequence","targetSequence","originSequenceClone","originTarget","_cloneTargetSequence","_getInsertIndex","insertLocationNode","insertBefore","insertAdjacentElement","submit","FxAction","script","action","case","targetid","prop","confirm","FxFunction","signature","override","functionBody","signatureParseResult","returnType","groups","functionIdentifier","paramParts","map","param","variableName","varType","variableType","fun","Function","paramPart","args","apply","reduce","variablesByName"],"mappings":"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"}